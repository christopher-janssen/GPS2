---
title: "GPS22 Project: Reverse Geocoding with Nominatim"
author: "Christopher Janssen"
date: "`r lubridate::today()`"
format:
  html:
    self-contained: true
editor_options:
  chunk_output_type: console
editor:
  markdown:
    wrap: 72
---

# Reverse Geocoding Analysis

This notebook performs reverse geocoding on GPS cluster centroids using the local Nominatim service to identify addresses and location types while maintaining privacy compliance.

## Package Management Setup

```{r setup}
source(here::here("scripts/r/setup.R"))
source(here::here("scripts/r/database.R"))
```

## Overview

We'll be processing:

- GPS cluster centroids from previous clustering analysis
- Rate-limited reverse geocoding via local Nominatim API
- Address parsing and location type classification
- Population of reverse_geocode_results table
- Address matching and deduplication

## Database Connection

```{r}
# Connect to database
con <- connect_gps_db()
```

## Infrastructure Verification

Verify Nominatim service is running and accessible:

```{r}
# Check Nominatim service status
nominatim_base_url <- "http://localhost:8080"
nominatim_status_url <- paste0(nominatim_base_url, "/status.php")

# Test Nominatim connection
response <- httr::GET(nominatim_status_url)
if (httr::status_code(response) != 200) {
  stop("Cannot connect to Nominatim service. Please start with: cd docker-compose && docker-compose up -d")
}
nominatim_status <- "running"
```

## GPS Clusters Status Check

Verify clustering results are available for reverse geocoding:

```{r}
# Check current GPS clusters status
clusters_count <- dbGetQuery(con, "SELECT COUNT(*) as total_clusters FROM gps_clusters")[1,1]
participants_with_clusters <- dbGetQuery(con, "SELECT COUNT(DISTINCT subject_id) as participants FROM gps_clusters")[1,1]

if (clusters_count == 0) {
  stop("No GPS clusters found. Please run 03-gps-processing-clustering.qmd first.")
}
```

## Load GPS Clusters for Geocoding

Extract cluster centroids and metadata for reverse geocoding:

```{r}
# Load GPS clusters with subject information
gps_clusters <- dbGetQuery(con, "
  SELECT 
    gc.cluster_id,
    s.subid,
    gc.lat,
    gc.lon,
    gc.n_points,
    gc.total_visits,
    gc.total_duration_hours,
    gc.first_visit,
    gc.last_visit
  FROM gps_clusters gc
  JOIN subjects s ON gc.subject_id = s.id
  ORDER BY s.subid, gc.total_visits DESC
")
```

## Rate Limiting Configuration

Set up rate limiting parameters for Nominatim API compliance:

```{r}
# Nominatim rate limiting parameters
requests_per_second <- 5  # Local Nominatim can handle higher rates (5 requests/second)
delay_between_requests <- 1 / requests_per_second

# Batch processing parameters  
batch_size <- 50  # Process in small batches for progress tracking
max_retries <- 3  # Retry failed requests

# Store parameters for inline reporting
rate_config <- list(
  requests_per_second = requests_per_second,
  delay_seconds = delay_between_requests,
  batch_size = batch_size
)
```

## Reverse Geocoding Function

Create function to query Nominatim with error handling and rate limiting:

```{r}
# Function to perform reverse geocoding with rate limiting
reverse_geocode_point <- function(lat, lon, cluster_id = NULL) {
  
  # Construct Nominatim reverse geocoding URL
  nominatim_url <- paste0(
    nominatim_base_url, "/reverse?",
    "lat=", lat,
    "&lon=", lon,
    "&format=jsonv2",
    "&addressdetails=1",
    "&zoom=18"  # High detail level for precise address matching
  )
  
  # Create safe geocoding function for single attempt
  safe_single_geocode <- safely(~ {
    response <- httr::GET(nominatim_url)
    
    if (httr::status_code(response) == 200) {
      result <- httr::content(response, "parsed", encoding = "UTF-8")
      
      # Check if we actually got useful geocoding data
      has_display_name <- !is.null(result$display_name) && nchar(result$display_name) > 0
      has_address <- !is.null(result$address) && length(result$address) > 0
      
      if (has_display_name && has_address) {
        # Extract address components
        address <- result$address
        
        list(
          cluster_id = cluster_id,
          lat = lat,
          lon = lon,
          display_name = result$display_name,
          house_number = address$house_number %||% NA,
          street = address$road %||% NA,
          city = address$city %||% address$town %||% address$village %||% NA,
          county = address$county %||% NA,
          state = address$state %||% NA,
          postal_code = address$postcode %||% NA,
          country = address$country %||% NA,
          place_type = result$type %||% NA,
          place_class = result$class %||% NA,
          confidence = result$importance %||% NA,
          geocode_timestamp = Sys.time(),
          success = TRUE,
          error_message = NA
        )
      } else {
        # HTTP 200 but no useful geocoding data
        list(
          cluster_id = cluster_id,
          lat = lat,
          lon = lon,
          success = FALSE,
          error_message = "No geocoding data found for coordinates",
          geocode_timestamp = Sys.time()
        )
      }
    } else {
      warning("HTTP ", httr::status_code(response), " for cluster ", cluster_id)
      stop("HTTP error: ", httr::status_code(response))
    }
  })
  
  # Attempt reverse geocoding with retries
  for (attempt in 1:max_retries) {
    result <- safe_single_geocode()
    
    if (is.null(result$error)) {
      return(result$result)
    } else {
      if (attempt == max_retries) {
        return(list(
          cluster_id = cluster_id,
          lat = lat,
          lon = lon,
          success = FALSE,
          error_message = as.character(result$error),
          geocode_timestamp = Sys.time()
        ))
      }
      Sys.sleep(delay_between_requests * 2)  # Double delay on error
    }
  }
  
  # If all retries failed
  return(list(
    cluster_id = cluster_id,
    lat = lat,
    lon = lon,
    success = FALSE,
    error_message = "All retry attempts failed",
    geocode_timestamp = Sys.time()
  ))
}
```

## Batch Reverse Geocoding

Process GPS clusters in batches with progress tracking:

```{r}
# Clear existing geocoding results before starting
dbExecute(con, "DELETE FROM reverse_geocode_results")

# Initialize progress tracking
total_clusters <- nrow(gps_clusters)
processed_count <- 0
success_count <- 0
failed_count <- 0

cat("Starting reverse geocoding with immediate database storage for", total_clusters, "clusters...\n")
start_time <- Sys.time()

# Helper function to insert geocoding result immediately
insert_geocoding_result <- function(result) {
  if (result$success) {
    # Insert successful result into reverse_geocode_results table
    geocoding_for_db <- tibble(
      cluster_id = result$cluster_id,
      address = result$display_name,
      city = result$city %||% NA,
      state = result$state %||% NA,
      country = result$country %||% NA,
      postcode = result$postal_code %||% NA,
      nominatim_json = NA,  # Could store full JSON if needed
      nominatim_place_id = NA
    )
    
    dbWriteTable(con, "reverse_geocode_results", geocoding_for_db,
                 append = TRUE, row.names = FALSE)
  }
  # Note: We could also insert failures into a separate table for analysis
}

# Process clusters in batches
for (batch_start in seq(1, total_clusters, by = batch_size)) {
  
  batch_end <- min(batch_start + batch_size - 1, total_clusters)
  batch_clusters <- gps_clusters[batch_start:batch_end, ]
  
  # Process each cluster in the batch
  for (i in 1:nrow(batch_clusters)) {
    cluster <- batch_clusters[i, ]
    
    # Perform reverse geocoding
    result <- reverse_geocode_point(
      lat = cluster$lat,
      lon = cluster$lon, 
      cluster_id = cluster$cluster_id
    )
    
    # Insert result immediately into database
    insert_geocoding_result(result)
    processed_count <- processed_count + 1
    
    if (result$success) {
      success_count <- success_count + 1
    } else {
      failed_count <- failed_count + 1
    }
    
    # Update status line (overwrite previous line)
    percent_complete <- round(processed_count / total_clusters * 100, 1)
    status_line <- sprintf("\r%s%% complete | %d/%d successful/failed | %d/%d inserted", 
                          percent_complete, success_count, failed_count, 
                          processed_count, total_clusters)
    cat(status_line)
    
    # Rate limiting delay
    Sys.sleep(delay_between_requests)
  }
  
  # Longer pause between batches
  if (batch_end < total_clusters) {
    Sys.sleep(2)
  }
}

# Show final status
end_time <- Sys.time()
elapsed_time <- round(as.numeric(difftime(end_time, start_time, units = "mins")), 1)

cat("\n\nReverse geocoding completed in", elapsed_time, "minutes\n")
cat("Final results:", success_count, "successful,", failed_count, "failed\n")
cat("All results stored directly in database\n")

# Store final count for reporting
final_processed_count <- processed_count
```

Processed `{r} final_processed_count` clusters with immediate database storage.

## Results Analysis (Database-Driven)

Analyze geocoding results using database queries for efficiency:

```{r}
# Get geocoding statistics from database
geocoding_stats <- dbGetQuery(con, "
  SELECT 
    COUNT(*) as successful_geocodes,
    COUNT(CASE WHEN address IS NOT NULL AND address != '' THEN 1 END) as valid_addresses
  FROM reverse_geocode_results
")

# Calculate failed geocodes by comparing total clusters to successful ones
total_stats <- dbGetQuery(con, "
  SELECT 
    COUNT(gc.cluster_id) as total_clusters,
    COUNT(rgr.cluster_id) as geocoded_clusters,
    COUNT(gc.cluster_id) - COUNT(rgr.cluster_id) as failed_clusters
  FROM gps_clusters gc
  LEFT JOIN reverse_geocode_results rgr ON gc.cluster_id = rgr.cluster_id
")

# Calculate success rate
success_rate <- round((total_stats$geocoded_clusters / total_stats$total_clusters) * 100, 1)
```

**Reverse Geocoding Results Summary:**
- Total clusters processed: `{r} total_stats$total_clusters`
- Successful geocodes: `{r} total_stats$geocoded_clusters`
- Failed geocodes: `{r} total_stats$failed_clusters`
- Success rate: `{r} success_rate`%

## Address Classification (Database Analysis)

Analyze location types and address completeness using database queries:

```{r}
# Address component completeness analysis from database
address_completeness <- dbGetQuery(con, "
  SELECT 
    ROUND(COUNT(CASE WHEN city IS NOT NULL AND city != '' THEN 1 END) * 100.0 / COUNT(*), 1) as has_city,
    ROUND(COUNT(CASE WHEN state IS NOT NULL AND state != '' THEN 1 END) * 100.0 / COUNT(*), 1) as has_state,
    ROUND(COUNT(CASE WHEN postcode IS NOT NULL AND postcode != '' THEN 1 END) * 100.0 / COUNT(*), 1) as has_postal_code,
    ROUND(COUNT(CASE WHEN country IS NOT NULL AND country != '' THEN 1 END) * 100.0 / COUNT(*), 1) as has_country
  FROM reverse_geocode_results
")

# Geographic distribution analysis
geographic_distribution <- dbGetQuery(con, "
  SELECT 
    state,
    COUNT(*) as location_count,
    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER (), 1) as percentage
  FROM reverse_geocode_results 
  WHERE state IS NOT NULL 
  GROUP BY state 
  ORDER BY location_count DESC
")
```

**Address Component Completeness:**
- Cities: `{r} address_completeness$has_city`%
- States: `{r} address_completeness$has_state`%  
- Postal codes: `{r} address_completeness$has_postal_code`%
- Countries: `{r} address_completeness$has_country`%

**Geographic Distribution: This should always be 100% Wisconsin ATM**
```{r}
#| echo: false
if (nrow(geographic_distribution) > 0) {
  knitr::kable(geographic_distribution, caption = "Geographic Distribution by State")
} else {
  cat("No geographic data available")
}
```

## GPS Clusters Address Update

Update the main GPS clusters table with successful geocoding results:

```{r}
# Add address column to gps_clusters if it doesn't exist
safe_alter <- possibly(~ dbExecute(con, "ALTER TABLE gps_clusters ADD COLUMN address TEXT"), 
                       otherwise = NULL, quiet = TRUE)
safe_alter()  # Column likely already exists if NULL returned

# Update gps_clusters with addresses from successful geocoding
rows_updated <- dbExecute(con, "
  UPDATE gps_clusters 
  SET address = rgr.address
  FROM reverse_geocode_results rgr
  WHERE gps_clusters.cluster_id = rgr.cluster_id
")

updated_clusters_count <- rows_updated
```

Updated `{r} updated_clusters_count` GPS clusters with address information from successful geocoding results.

## Quality Assessment (Database Analysis)

Assess geocoding quality using database queries:

```{r}
# Create quality assessment based on address component completeness
quality_analysis <- dbGetQuery(con, "
  SELECT 
    CASE 
      WHEN (CASE WHEN city IS NOT NULL AND city != '' THEN 1 ELSE 0 END + 
            CASE WHEN state IS NOT NULL AND state != '' THEN 1 ELSE 0 END + 
            CASE WHEN postcode IS NOT NULL AND postcode != '' THEN 1 ELSE 0 END + 
            CASE WHEN country IS NOT NULL AND country != '' THEN 1 ELSE 0 END) >= 3 
        THEN 'High Quality'
      WHEN (CASE WHEN city IS NOT NULL AND city != '' THEN 1 ELSE 0 END + 
            CASE WHEN state IS NOT NULL AND state != '' THEN 1 ELSE 0 END + 
            CASE WHEN postcode IS NOT NULL AND postcode != '' THEN 1 ELSE 0 END + 
            CASE WHEN country IS NOT NULL AND country != '' THEN 1 ELSE 0 END) = 2 
        THEN 'Medium Quality'
      WHEN (CASE WHEN city IS NOT NULL AND city != '' THEN 1 ELSE 0 END + 
            CASE WHEN state IS NOT NULL AND state != '' THEN 1 ELSE 0 END + 
            CASE WHEN postcode IS NOT NULL AND postcode != '' THEN 1 ELSE 0 END + 
            CASE WHEN country IS NOT NULL AND country != '' THEN 1 ELSE 0 END) = 1 
        THEN 'Low Quality'
      ELSE 'Poor Quality'
    END as quality_category,
    COUNT(*) as n,
    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER (), 1) as percentage
  FROM reverse_geocode_results
  GROUP BY quality_category
  ORDER BY n DESC
")
```

```{r}
#| echo: false
if (nrow(quality_analysis) > 0) {
  knitr::kable(quality_analysis, caption = "Geocoding Quality Assessment")
} else {
  cat("No successful results available for quality assessment")
}
```

## Error Analysis (Database Analysis)

Analyze failed geocoding attempts by comparing total clusters to successful geocodes:

```{r}
# Get coordinates of failed geocoding attempts
failed_analysis <- dbGetQuery(con, "
  SELECT 
    gc.cluster_id,
    gc.lat,
    gc.lon,
    CASE 
      WHEN gc.lat NOT BETWEEN 42.0 AND 47.5 OR gc.lon NOT BETWEEN -93.0 AND -86.0 
        THEN 'Outside Wisconsin bounds'
      ELSE 'Within Wisconsin bounds'
    END as location_category,
    COUNT(*) OVER (PARTITION BY 
      CASE 
        WHEN gc.lat NOT BETWEEN 42.0 AND 47.5 OR gc.lon NOT BETWEEN -93.0 AND -86.0 
          THEN 'Outside Wisconsin bounds'
        ELSE 'Within Wisconsin bounds'
      END) as category_count
  FROM gps_clusters gc
  LEFT JOIN reverse_geocode_results rgr ON gc.cluster_id = rgr.cluster_id
  WHERE rgr.cluster_id IS NULL
  ORDER BY gc.lat, gc.lon
  LIMIT 20
")

# Summary of failure reasons
failure_summary <- dbGetQuery(con, "
  SELECT 
    CASE 
      WHEN gc.lat NOT BETWEEN 42.0 AND 47.5 OR gc.lon NOT BETWEEN -93.0 AND -86.0 
        THEN 'Outside Wisconsin bounds'
      ELSE 'Within Wisconsin bounds (Nominatim gap)'
    END as failure_reason,
    COUNT(*) as failure_count,
    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER (), 1) as percentage
  FROM gps_clusters gc
  LEFT JOIN reverse_geocode_results rgr ON gc.cluster_id = rgr.cluster_id
  WHERE rgr.cluster_id IS NULL
  GROUP BY failure_reason
  ORDER BY failure_count DESC
")
```

**Failed Geocoding Analysis:**
- Total failed clusters: `{r} sum(failure_summary$failure_count)`

**Failure Reasons:**
```{r}
#| echo: false
if (nrow(failure_summary) > 0) {
  knitr::kable(failure_summary, caption = "Failure Analysis by Geographic Location")
} else {
  cat("No failed geocoding attempts to analyze")
}
```

**Sample Failed Coordinates:**
```{r}
#| echo: false
if (nrow(failed_analysis) > 0) {
  failed_sample <- failed_analysis[1:min(10, nrow(failed_analysis)), c("cluster_id", "lat", "lon", "location_category")]
  knitr::kable(failed_sample, caption = "Sample Failed Coordinates")
}
```

## Database Connection Cleanup

```{r}
# Close database connection
disconnect_gps_db(con)
```

### Troubleshooting Commands

```{bash eval=FALSE}
# Check Nominatim service status
# curl http://localhost:8080/status.php

# Test manual geocoding
# curl "http://localhost:8080/reverse?lat=43.0731&lon=-89.4012&format=json"

# Check reverse geocoding results in database
# docker-compose exec -T postgis psql -U postgres -d gps_analysis -c "SELECT success, COUNT(*) FROM reverse_geocode_results GROUP BY success;"

# View sample geocoding results  
# docker-compose exec -T postgis psql -U postgres -d gps_analysis -c "SELECT display_name, place_type, city FROM reverse_geocode_results WHERE success = true LIMIT 10;"
```