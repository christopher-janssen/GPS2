---
title: "GPS22 Project: Interactive Visualizations"
author: "Christopher Janssen"
date: "`r lubridate::today()`"
format:
  html:
    self-contained: true
    code-fold: false
    toc: true
    toc-depth: 3
editor_options:
  chunk_output_type: console
editor:
  markdown:
    wrap: 72
---

# Interactive GPS Visualization Showcase

This notebook demonstrates the complete GPS22 visualization workflow
using the refactored `pull_db()` data loading system and interactive
Leaflet maps. All visualizations use the new **data-first,
visualization-second** approach for clean, R-idiomatic code.

## Setup

```{r setup, message=FALSE}
source(here::here("scripts/r/setup.R"))
source(here::here("scripts/r/database.R"))
source(here::here("scripts/r/popup_utils.R"))
source(here::here("scripts/r/visualization.R"))
```

```{r connect}
con <- connect_gps_db()
```

## Data Loading Overview

The `pull_db()` system provides numbered references for data access:

-   **`pull_db(1)`** - Raw GPS points with coordinates and timestamps
-   **`pull_db(2)`** - Processed GPS with movement states and clustering
-   **`pull_db(3)`** - Location clusters with visit statistics and
    geocoding
-   **`pull_db(4)`** - Pure geocoding results for address analysis
-   **`pull_db(5)`** - Analysis-ready joined dataset
-   **`pull_db(6)`** - Madison zoning districts with spatial polygons

## Available Participants

```{r check-participants}
# Get overview of available data
participants <- dbGetQuery(con, "
  SELECT 
    s.subid,
    COUNT(DISTINCT gc.cluster_id) as clusters,
    COUNT(DISTINCT CASE WHEN rgr.address IS NOT NULL THEN gc.cluster_id END) as geocoded,
    MIN(gc.first_visit)::date as start_date,
    MAX(gc.last_visit)::date as end_date
  FROM subjects s
  JOIN gps_clusters gc ON s.id = gc.subject_id
  LEFT JOIN reverse_geocode_results rgr ON gc.cluster_id = rgr.cluster_id
  GROUP BY s.subid
  ORDER BY clusters DESC
  LIMIT 10
")

participants |> 
  mutate(
    geocoded_pct = round(geocoded / clusters * 100, 1),
    duration_days = as.numeric(end_date - start_date)
  ) |>
  knitr::kable(
    caption = "Top 10 Participants by Cluster Count",
    col.names = c("Participant", "Clusters", "Geocoded", "Start Date", "End Date", "Geocoded %", "Duration (days)")
  )
```

# Interactive Cluster Visualizations

## Single Participant Analysis

Let's visualize a participant with good geocoding coverage:

```{r select-participant}
# Select a participant with good data
# Load cluster data

cluster_data <- pull_db(3, subid = 66)
```

### Location Cluster Map (Visit Frequency)

The default visualization colors clusters by visit frequency using our
Material Design palette:

```{r cluster-map-visits}
# Create interactive cluster map colored by visit frequency
# Legend shows consistent global thresholds for all participants
cluster_data |>
  plot_cluster_map(
    color_by = "visits", 
    show_legend = TRUE
  )
```

**Global Visit Categories (consistent across all participants):** -
**Rare (1 visit)**: Single-visit locations\
- **Occasional (2-4 visits)**: Infrequently visited places - **Frequent
(5-9 visits)**: Regularly visited locations - **Routine (10+ visits)**:
Most frequently visited places

### Location Cluster Map (Duration-Based)

Alternative coloring based on time spent at each location:

```{r cluster-map-duration}
# Color clusters by average duration per visit
cluster_data |>
  plot_cluster_map(
    color_by = "duration",
    show_legend = TRUE
  )
```

**Global Duration Categories (average time per visit):** - **Brief Stops
(\<1h avg)**: Quick stops and errands - **Short Stays (1-2h avg)**:
Brief but meaningful visits\
- **Medium Stays (2-4h avg)**: Extended activities - **Long Stays (4-8h
avg)**: Major time commitments - **Extended Stays (8h+ avg)**: Work,
sleep, or primary locations

## Multiple Participant Comparison

### Cluster Distribution Analysis

Compare location patterns across multiple participants:

```{r multi-participant-analysis}
# Load data for top 5 participants
top_participants <- participants$subid[1:5]

multi_participant_data <- pull_db(3) |>
  filter(subid %in% top_participants) |>
  classify_location_importance(method = "visits")

# Analyze location type distribution
location_distribution <- multi_participant_data |>
  group_by(subid, location_type) |>
  summarise(
    count = n(),
    avg_visits = round(mean(total_visits), 1),
    total_hours = round(sum(total_duration_hours), 1),
    .groups = "drop"
  ) |>
  pivot_wider(
    names_from = location_type,
    values_from = c(count, avg_visits, total_hours),
    values_fill = 0
  )

location_distribution |>
  select(subid, starts_with("count_")) |>
  knitr::kable(
    caption = "Location Type Counts by Participant",
    col.names = c("Participant", "Routine", "Frequent", "Occasional", "Rare")
  )
```

# Raw GPS Point Visualizations

## Movement Patterns

For detailed movement analysis, we can visualize raw GPS points:

```{r raw-gps-sample}
# Load sample of raw GPS data (limited for performance)
raw_gps_sample <- pull_db(1, subid = 66, limit = 500)
cat("Loaded", nrow(raw_gps_sample), "GPS points\n")

# Create movement pattern map with paths
movement_map <- raw_gps_sample |>
  plot_gps_points(
    subid = 66,
    show_paths = FALSE
  )

movement_map
```

## Temporal Movement Analysis

### Movement Timeline Plot

Analyze movement states over time:

```{r movement-timeline}
# Create movement timeline (using more data)
timeline_data <- pull_db(2, subid = 10, limit = 2000)

if (nrow(timeline_data) > 0) {
  timeline_plot <- timeline_data |>
    plot_movement_timeline(subid = 10)
  
  timeline_plot
} else {
  cat("No movement data available for timeline\n")
}
```

### Spatial Density Heatmap

Visualize spatial usage patterns:

```{r spatial-density}
# Create spatial density plot
if (nrow(timeline_data) > 0) {
  density_plot <- timeline_data |>
    plot_spatial_density(subid = 10)
  
  density_plot
} else {
  cat("No GPS data available for density plot\n")
}
```

# Geocoding Analysis

## Address Coverage Analysis

Analyze the success of reverse geocoding:

```{r geocoding-analysis}
# Pull geocoding results
geocoded_results <- pull_db(4, successful_only = FALSE)

geocoding_summary <- geocoded_results |>
  group_by(subid) |>
  summarise(
    total_clusters = n(),
    successful_geocoding = sum(geocoding_success, na.rm = TRUE),
    success_rate = round(successful_geocoding / total_clusters * 100, 1),
    unique_cities = n_distinct(city, na.rm = TRUE),
    .groups = "drop"
  ) |>
  arrange(desc(success_rate))

geocoding_summary |>
  head(10) |>
  knitr::kable(
    caption = "Geocoding Success Rates by Participant",
    col.names = c("Participant", "Total Clusters", "Geocoded", "Success Rate %", "Unique Cities")
  )
```

## Geographic Distribution

Analyze the geographic spread of successfully geocoded locations:

```{r geographic-distribution}
# Analyze city distribution
city_distribution <- geocoded_results |>
  filter(geocoding_success == TRUE, !is.na(city)) |>
  count(city, state, sort = TRUE) |>
  head(15)

city_distribution |>
  knitr::kable(
    caption = "Top 15 Cities in Dataset",
    col.names = c("City", "State", "Cluster Count")
  )
```

# Madison Zoning Analysis

## Zoning District Overview

Visualize Madison's zoning districts to understand the spatial context
of GPS locations:

```{r zoning-overview}
# Show zoning category distribution
zoning_summary <- pull_db(6) |>
  st_drop_geometry() |>
  group_by(zone_category) |>
  summarise(
    n_districts = n(),
    total_area_km2 = round(sum(area_sqm, na.rm = TRUE) / 1000000, 1),
    avg_area_hectares = round(mean(area_sqm, na.rm = TRUE) / 10000, 1),
    .groups = "drop"
  ) |>
  arrange(desc(total_area_km2))

zoning_summary |>
  knitr::kable(
    caption = "Madison Zoning Districts by Category",
    col.names = c("Zone Category", "Districts", "Total Area (km²)", "Avg Area (hectares)")
  )
```

## Interactive Zoning Map

Explore Madison's zoning districts with toggleable categories:

```{r zoning-map}
# Create interactive zoning visualization
pull_db(6) |>
  plot_zoning_map(
    show_legend = TRUE,
    layer_controls = TRUE
  )
```

**Zoning Categories:**

-   **Residential** (Green): Various residential districts from low to
    high density
-   **Commercial** (Orange): Business and retail districts
-   **Mixed-Use** (Blue): Combined residential, commercial, and office
    spaces
-   **Downtown** (Brown): High-density urban core areas
-   **Employment** (Purple): Office parks and employment centers
-   **Industrial** (Blue-Grey): Manufacturing and industrial zones
-   **Special** (Red): Institutional, parks, and special-purpose areas

Check Research Drive for exact zoning specifications.

# Area Deprivation Index (ADI) Analysis

## ADI Overview

Explore socioeconomic context through the Area Deprivation Index:

```{r adi-overview}
# Load clusters with ADI data
adi_clusters <- dbGetQuery(con, "
  SELECT * FROM v_clusters_with_adi
  WHERE adi_national_percentile IS NOT NULL
") |>
  st_as_sf(coords = c("lon", "lat"), crs = 4326, remove = FALSE)

# Summary statistics
adi_summary <- adi_clusters |>
  st_drop_geometry() |>
  summarise(
    total_clusters = n(),
    unique_subjects = n_distinct(subid),
    mean_adi = round(mean(adi_national_percentile, na.rm = TRUE), 1),
    median_adi = round(median(adi_national_percentile, na.rm = TRUE), 1),
    high_deprivation = sum(adi_national_percentile >= 70),
    low_deprivation = sum(adi_national_percentile < 40)
  )

adi_summary |>
  knitr::kable(
    caption = "ADI-Linked GPS Cluster Summary",
    col.names = c("Total Clusters", "Subjects", "Mean ADI", "Median ADI", "High Deprivation (≥70)", "Low Deprivation (<40)")
  )
```

```{r adi-distribution}
# Distribution by deprivation category
adi_clusters |>
  st_drop_geometry() |>
  count(deprivation_category) |>
  arrange(desc(n)) |>
  mutate(pct = round(n / sum(n) * 100, 1)) |>
  knitr::kable(
    caption = "GPS Clusters by Deprivation Level",
    col.names = c("Deprivation Category", "Cluster Count", "Percentage")
  )
```

## Subject-Level ADI Exposure

```{r subject-adi-exposure}
# Load subject-level ADI summaries
subject_adi <- dbGetQuery(con, "
  SELECT * FROM v_subject_adi_exposure
  ORDER BY mean_adi_percentile DESC
  LIMIT 15
")

subject_adi |>
  select(subid, total_clusters_with_adi, mean_adi_percentile, time_weighted_adi,
         high_deprivation_clusters, low_deprivation_clusters) |>
  knitr::kable(
    caption = "Top 15 Subjects by Mean ADI Exposure",
    col.names = c("Subject", "Clusters", "Mean ADI", "Time-Weighted ADI",
                  "High Dep. Clusters", "Low Dep. Clusters")
  )
```

## Interactive ADI Map

Visualize GPS clusters colored by area deprivation:

```{r adi-map}
# Generate interactive ADI map
adi_clusters |>
  plot_adi_map(show_legend = TRUE, layer_controls = TRUE)
```

**ADI Interpretation:**

-   **National Percentile (1-100)**: Higher values indicate greater
    neighborhood deprivation
-   **Very High Deprivation (85-100)**: Most disadvantaged neighborhoods
    nationally
-   **High Deprivation (70-84)**: Above-average deprivation
-   **Moderate Deprivation (40-69)**: Average socioeconomic status
-   **Low/Very Low (\<40)**: Below-average deprivation (more advantaged
    areas)

ADI captures factors including income, education, employment, and
housing quality at the Census block group level.

## ADI Geographic Distribution

Visualize the actual Census block group polygons colored by
deprivation level:

```{r adi-block-groups}
# Load ADI block group polygons
adi_block_groups <- dbGetQuery(con, "
  SELECT
    fips_2020,
    state_postal,
    adi_national_percentile,
    adi_state_decile,
    area_sqm,
    ST_AsText(geom) as geom
  FROM adi_block_groups
") |>
  st_as_sf(wkt = "geom", crs = 4326)

# Create interactive map of ADI polygons
adi_block_groups |>
  plot_adi_block_groups(show_legend = TRUE, layer_controls = TRUE)
```

**Map Features:**

-   **Toggle layers** to focus on specific deprivation levels
-   **Click polygons** to see FIPS codes and ADI scores
-   Census block groups are the smallest geographic unit for ADI data
-   Wisconsin coverage: 4,609 block groups spanning the entire state

This shows the geographic distribution of neighborhood deprivation
across Wisconsin, providing context for where study participants spend
their time.

```{r cleanup}
# Clean up
disconnect_gps_db(con)
cat("✓ Visualization showcase complete!")
```
