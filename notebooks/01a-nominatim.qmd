---
title: "Nominatim OSM Data Exploration"
author: "Christopher Janssen"
date: "`r lubridate::today()`"
format:
  html:
    self-contained: true
    toc: true
    toc-depth: 3
    code-fold: show
editor_options:
  chunk_output_type: console
---

# Overview

This notebook explores the Wisconsin OpenStreetMap (OSM) data available in the local Nominatim container. Nominatim provides geocoding and reverse geocoding services using OSM data.

## Setup

```{r setup}
#| message: false
#| warning: false

source(here::here("scripts/r/setup.R"))
```

## Helper Function

Since Nominatim runs in a separate Docker container, we can't connect directly from R. This helper function executes SQL queries via docker:

```{r}
#' Query the Nominatim database via docker exec
#' @param sql SQL query string
#' @param format Output format: "df" for data frame, "text" for raw text
query_nominatim <- function(sql, format = "df") {
  # Escape quotes in SQL
  sql_escaped <- gsub('"', '\\"', sql, fixed = TRUE)

  # Build docker command
  if (format == "df") {
    # Use -t flag for formatted table output
    cmd <- sprintf(
      'docker exec gps-nominatim sudo -u postgres psql -d nominatim -t -c "%s"',
      sql_escaped
    )
  } else {
    cmd <- sprintf(
      'docker exec gps-nominatim sudo -u postgres psql -d nominatim -c "%s"',
      sql_escaped
    )
  }

  # Execute and return results
  result <- system(cmd, intern = TRUE)

  if (format == "df" && length(result) > 0) {
    # Parse pipe-delimited output
    # Filter out separator lines and empty lines
    result <- result[!grepl("^-+\\|", result) & nchar(trimws(result)) > 0]

    if (length(result) > 0) {
      # Split by pipe and trim whitespace
      parsed <- lapply(result, function(line) {
        trimws(strsplit(line, "\\|")[[1]])
      })

      # First row is header
      if (length(parsed) > 1) {
        header <- parsed[[1]]
        data <- do.call(rbind, lapply(parsed[-1], function(x) x))
        df <- as.data.frame(data, stringsAsFactors = FALSE)
        colnames(df) <- header

        # Try to convert numeric columns
        for (col in colnames(df)) {
          suppressWarnings({
            numeric_col <- as.numeric(df[[col]])
            if (!all(is.na(numeric_col))) {
              df[[col]] <- numeric_col
            }
          })
        }

        return(df)
      }
    }
  }

  return(result)
}

# Test the function
query_nominatim("SELECT COUNT(*) as total_places FROM placex;")
```

# Database Overview

## Size and Table Counts

```{r}
# Get table sizes for key tables
table_sizes <- query_nominatim("
SELECT
  schemaname,
  tablename,
  pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size
FROM pg_tables
WHERE schemaname = 'public'
  AND tablename IN ('placex', 'place', 'location_postcode', 'location_property_osmline',
                    'search_name', 'planet_osm_nodes', 'planet_osm_ways', 'planet_osm_rels',
                    'country_name', 'place_addressline')
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;
")

knitr::kable(table_sizes, caption = "Key Nominatim Tables and Sizes")
```

## Overall Statistics

```{r}
# Total counts
stats <- list(
  places = query_nominatim("SELECT COUNT(*) FROM placex;")[1],
  nodes = query_nominatim("SELECT COUNT(*) FROM planet_osm_nodes;")[1],
  ways = query_nominatim("SELECT COUNT(*) FROM planet_osm_ways;")[1],
  relations = query_nominatim("SELECT COUNT(*) FROM planet_osm_rels;")[1],
  postcodes = query_nominatim("SELECT COUNT(*) FROM location_postcode;")[1]
)

data.frame(
  Metric = c("Total Places (placex)", "OSM Nodes", "OSM Ways", "OSM Relations", "US Postcodes"),
  Count = c(stats$places, stats$nodes, stats$ways, stats$relations, stats$postcodes)
) |>
  knitr::kable(format.args = list(big.mark = ","), caption = "Nominatim Database Statistics")
```

# Place Classification

The main `placex` table contains geocoded places organized by `class` and `type`. This creates a hierarchical categorization system.

## Class-Level Summary

```{r}
class_summary <- query_nominatim("
SELECT
  class,
  COUNT(*) as n_places,
  COUNT(DISTINCT type) as n_types,
  ROUND(100.0 * COUNT(*) / SUM(COUNT(*)) OVER (), 2) as pct_of_total
FROM placex
GROUP BY class
ORDER BY n_places DESC;
")

knitr::kable(
  class_summary,
  col.names = c("Class", "Places", "Types", "% of Total"),
  format.args = list(big.mark = ","),
  caption = "Place Classes in Wisconsin OSM Data"
)
```

# Detailed Type Breakdowns

## Buildings

```{r}
building_types <- query_nominatim("
SELECT
  type,
  COUNT(*) as n_places,
  COUNT(CASE WHEN name IS NOT NULL THEN 1 END) as n_with_name,
  ROUND(100.0 * COUNT(*) / SUM(COUNT(*)) OVER (), 2) as pct
FROM placex
WHERE class = 'building'
GROUP BY type
ORDER BY n_places DESC
LIMIT 30;
")

knitr::kable(
  building_types,
  col.names = c("Type", "Count", "Named", "% of Buildings"),
  format.args = list(big.mark = ","),
  caption = "Top 30 Building Types"
)
```

## Highways (Roads & Transportation)

```{r}
highway_types <- query_nominatim("
SELECT
  type,
  COUNT(*) as n_places,
  COUNT(CASE WHEN name IS NOT NULL THEN 1 END) as n_with_name,
  ROUND(100.0 * COUNT(*) / SUM(COUNT(*)) OVER (), 2) as pct
FROM placex
WHERE class = 'highway'
GROUP BY type
ORDER BY n_places DESC
LIMIT 25;
")

knitr::kable(
  highway_types,
  col.names = c("Type", "Count", "Named", "% of Highways"),
  format.args = list(big.mark = ","),
  caption = "Top 25 Highway/Road Types"
)
```

## Shops

```{r}
shop_types <- query_nominatim("
SELECT
  type,
  COUNT(*) as n_places,
  COUNT(CASE WHEN name IS NOT NULL THEN 1 END) as n_with_name
FROM placex
WHERE class = 'shop'
GROUP BY type
ORDER BY n_places DESC
LIMIT 40;
")

knitr::kable(
  shop_types,
  col.names = c("Shop Type", "Count", "Named"),
  format.args = list(big.mark = ","),
  caption = "Top 40 Shop Types"
)
```

## Amenities

```{r}
amenity_types <- query_nominatim("
SELECT
  type,
  COUNT(*) as n_places,
  COUNT(CASE WHEN name IS NOT NULL THEN 1 END) as n_with_name
FROM placex
WHERE class = 'amenity'
GROUP BY type
ORDER BY n_places DESC
LIMIT 40;
")

knitr::kable(
  amenity_types,
  col.names = c("Amenity Type", "Count", "Named"),
  format.args = list(big.mark = ","),
  caption = "Top 40 Amenity Types"
)
```

## Leisure

```{r}
leisure_types <- query_nominatim("
SELECT
  type,
  COUNT(*) as n_places,
  COUNT(CASE WHEN name IS NOT NULL THEN 1 END) as n_with_name
FROM placex
WHERE class = 'leisure'
GROUP BY type
ORDER BY n_places DESC;
")

knitr::kable(
  leisure_types,
  col.names = c("Leisure Type", "Count", "Named"),
  format.args = list(big.mark = ","),
  caption = "Leisure Facility Types"
)
```

## Tourism

```{r}
tourism_types <- query_nominatim("
SELECT
  type,
  COUNT(*) as n_places,
  COUNT(CASE WHEN name IS NOT NULL THEN 1 END) as n_with_name
FROM placex
WHERE class = 'tourism'
GROUP BY type
ORDER BY n_places DESC;
")

knitr::kable(
  tourism_types,
  col.names = c("Tourism Type", "Count", "Named"),
  format.args = list(big.mark = ","),
  caption = "Tourism Feature Types"
)
```

## Places (Named Locations)

```{r}
place_types <- query_nominatim("
SELECT
  type,
  COUNT(*) as n_places,
  COUNT(CASE WHEN name IS NOT NULL THEN 1 END) as n_with_name,
  ROUND(100.0 * COUNT(*) / SUM(COUNT(*)) OVER (), 2) as pct
FROM placex
WHERE class = 'place'
GROUP BY type
ORDER BY n_places DESC;
")

knitr::kable(
  place_types,
  col.names = c("Place Type", "Count", "Named", "% of Places"),
  format.args = list(big.mark = ","),
  caption = "Named Place Types"
)
```

## Natural Features

```{r}
natural_types <- query_nominatim("
SELECT
  type,
  COUNT(*) as n_places,
  COUNT(CASE WHEN name IS NOT NULL THEN 1 END) as n_with_name
FROM placex
WHERE class = 'natural'
GROUP BY type
ORDER BY n_places DESC;
")

knitr::kable(
  natural_types,
  col.names = c("Natural Type", "Count", "Named"),
  format.args = list(big.mark = ","),
  caption = "Natural Feature Types"
)
```

## Waterways

```{r}
waterway_types <- query_nominatim("
SELECT
  type,
  COUNT(*) as n_places,
  COUNT(CASE WHEN name IS NOT NULL THEN 1 END) as n_with_name
FROM placex
WHERE class = 'waterway'
GROUP BY type
ORDER BY n_places DESC;
")

knitr::kable(
  waterway_types,
  col.names = c("Waterway Type", "Count", "Named"),
  format.args = list(big.mark = ","),
  caption = "Waterway Types"
)
```

## Man-Made Structures

```{r}
manmade_types <- query_nominatim("
SELECT
  type,
  COUNT(*) as n_places,
  COUNT(CASE WHEN name IS NOT NULL THEN 1 END) as n_with_name
FROM placex
WHERE class = 'man_made'
GROUP BY type
ORDER BY n_places DESC
LIMIT 25;
")

knitr::kable(
  manmade_types,
  col.names = c("Man-Made Type", "Count", "Named"),
  format.args = list(big.mark = ","),
  caption = "Top 25 Man-Made Structure Types"
)
```

## Healthcare

```{r}
healthcare_types <- query_nominatim("
SELECT
  type,
  COUNT(*) as n_places,
  COUNT(CASE WHEN name IS NOT NULL THEN 1 END) as n_with_name
FROM placex
WHERE class = 'healthcare'
GROUP BY type
ORDER BY n_places DESC;
")

knitr::kable(
  healthcare_types,
  col.names = c("Healthcare Type", "Count", "Named"),
  format.args = list(big.mark = ","),
  caption = "Healthcare Facility Types"
)
```

## Administrative Boundaries

```{r}
boundary_levels <- query_nominatim("
SELECT
  admin_level,
  COUNT(*) as count,
  STRING_AGG(DISTINCT type, ', ' ORDER BY type) as types
FROM placex
WHERE class = 'boundary' AND type = 'administrative'
GROUP BY admin_level
ORDER BY admin_level;
")

knitr::kable(
  boundary_levels,
  col.names = c("Admin Level", "Count", "Types"),
  caption = "Administrative Boundary Levels (4=State, 6=County, 8=City/Town)"
)
```

# Data Structure

## Key Columns in `placex` Table

The main `placex` table has these important columns:

- **osm_type/osm_id**: Original OpenStreetMap identifiers (N=node, W=way, R=relation)
- **class/type**: Categorical classification (e.g., 'amenity'/'restaurant')
- **name**: hstore with multilingual names (`name->'name'` for English)
- **address**: hstore with address components (street, city, state, etc.)
- **housenumber**: Street number
- **postcode**: ZIP/postal code
- **geometry**: Full spatial geometry (polygons, lines, points)
- **centroid**: Point geometry for location (use this for coordinates)
- **rank_address/rank_search**: Hierarchical importance (0-30, lower = more important)
- **extratags**: Additional OSM tags (hours, phone, website, etc.)

## Example: Viewing Address Data

```{r}
# Sample amenities with full address data
sample_addresses <- query_nominatim("
SELECT
  osm_type,
  class,
  type,
  name->'name' as name,
  address->'street' as street,
  address->'city' as city,
  address->'state' as state,
  housenumber,
  postcode
FROM placex
WHERE name->'name' IS NOT NULL
  AND class = 'amenity'
  AND type IN ('restaurant', 'bar', 'cafe')
  AND address->'city' = 'Madison'
LIMIT 15;
", format = "text")

# Display raw output
cat(paste(sample_addresses, collapse = "\n"))
```

# Example Queries

## Finding Specific POI Types

### All bars and restaurants in Madison

```{sql eval=FALSE}
SELECT
  name->'name' as name,
  address->'street' as street,
  housenumber,
  postcode,
  ST_Y(centroid) as latitude,
  ST_X(centroid) as longitude
FROM placex
WHERE address->'city' = 'Madison'
  AND class = 'amenity'
  AND type IN ('bar', 'restaurant', 'pub', 'cafe');
```

### All healthcare facilities

```{sql eval=FALSE}
SELECT
  class,
  type,
  name->'name' as name,
  address->'city' as city,
  address->'street' as street,
  ST_Y(centroid) as latitude,
  ST_X(centroid) as longitude
FROM placex
WHERE class IN ('healthcare', 'amenity')
  AND type IN ('hospital', 'clinic', 'doctors', 'dentist', 'pharmacy');
```

### Schools by type

```{sql eval=FALSE}
SELECT
  CASE
    WHEN type = 'kindergarten' THEN 'Kindergarten'
    WHEN type = 'school' THEN 'K-12 School'
    WHEN type = 'college' THEN 'College'
    WHEN type = 'university' THEN 'University'
    ELSE type
  END as school_type,
  name->'name' as name,
  address->'city' as city,
  ST_Y(centroid) as latitude,
  ST_X(centroid) as longitude
FROM placex
WHERE class = 'amenity'
  AND type IN ('kindergarten', 'school', 'college', 'university');
```
