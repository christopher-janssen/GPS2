---
title: "Load Public Data Sources"
author: "Christopher Janssen"
date: "`r lubridate::today()`"
format:
  html:
    self-contained: true
editor_options:
  chunk_output_type: console
editor:
  markdown:
    wrap: 72
---

## Introduction

This notebook will be populating the `geolocation` database with the current public data sources used in this project.

## Setup

```{r}
source(here::here("scripts/r/setup.R"))
source(here::here("scripts/r/connection.R"))

# Connect to database
con <- connect_to_db()
```

## Load OpenStreetMap POI Data

This section loads OpenStreetMap points of interest (POI) for Wisconsin from the archived GeoPackage into the database.

**Source:** `osm_poi_wisconsin.gpkg` (extracted from Nominatim)
**Target:** `public_data.osm_poi`
**Expected:** ~50k-100k points

### Load POI from GeoPackage

```{r}
# Path to archived POI data
poi_path <- str_c(path_gps2, "/nominatim/osm_poi_wisconsin.gpkg")

# Read POI data
osm_poi <- st_read(poi_path)
```

### Preview Data

```{r}
# Show structure
glimpse(osm_poi)
```

```{r}
# Sample records
osm_poi |>
  slice_head(n = 10) |>
  st_drop_geometry() |>
  select(osm_id, class, type, city, lat, lon)
```

```{r}
# Count by class
osm_poi |>
  st_drop_geometry() |>
  count(class, sort = TRUE)
```

### Write to Database

```{r}
# Write to public_data.osm_poi
st_write(osm_poi,
         con,
         Id(schema = "public_data", table = "osm_poi"),
         append = FALSE)
```

### Verify Load

```{r}
# Check row count
dbGetQuery(con, "SELECT COUNT(*) as row_count FROM public_data.osm_poi")
```

```{r}
# Check by class
dbGetQuery(con, "
SELECT
    class,
    COUNT(*) as count
FROM public_data.osm_poi
GROUP BY class
ORDER BY count DESC
LIMIT 10;
")
```

```{r}
# Sample records from database
dbGetQuery(con, "
SELECT
    osm_id,
    class,
    type,
    city
FROM public_data.osm_poi
LIMIT 10;
")
```

### Summary

```{r}
# Final statistics
dbGetQuery(con, "
SELECT
    COUNT(*) as total_points,
    COUNT(DISTINCT class) as unique_classes,
    COUNT(DISTINCT type) as unique_types,
    COUNT(geom) as points_with_geometry
FROM public_data.osm_poi;
")
```

## Load OpenStreetMap Landuse Data

This section loads OpenStreetMap landuse polygons for Wisconsin from the archived GeoPackage into the database.

**Source:** `osm_landuse_wisconsin.gpkg` (extracted from Nominatim)
**Target:** `public_data.osm_landuse`
**Expected:** ~10k-50k polygons

## Load Landuse from GeoPackage

```{r}
# Path to archived landuse data
landuse_path <- str_c(path_gps2, "/nominatim/osm_landuse_wisconsin.gpkg")

# Read landuse data
osm_landuse <- st_read(landuse_path)
```

## Preview Data

```{r}
# Show structure
glimpse(osm_landuse)
```

```{r}
# Sample records
osm_landuse |>
  slice_head(n = 10) |>
  st_drop_geometry() |>
  select(osm_id, class, type, city, area_sqkm)
```

```{r}
# Count by class
osm_landuse |>
  st_drop_geometry() |>
  count(class, sort = TRUE)
```

```{r}
# Top 10 largest polygons
osm_landuse |>
  st_drop_geometry() |>
  arrange(desc(area_sqkm)) |>
  select(osm_id, class, type, area_sqkm) |>
  slice_head(n = 10)
```

## Write to Database

```{r}
# Write to public_data.osm_landuse
st_write(osm_landuse,
         con,
         Id(schema = "public_data", table = "osm_landuse"),
         append = FALSE)
```

## Verify Load

```{r}
# Check row count
dbGetQuery(con, "SELECT COUNT(*) as row_count FROM public_data.osm_landuse")
```

```{r}
# Check by class
dbGetQuery(con, "
SELECT
    class,
    COUNT(*) as count
FROM public_data.osm_landuse
GROUP BY class
ORDER BY count DESC;
")
```

```{r}
# Sample records from database
dbGetQuery(con, "
SELECT
    osm_id,
    class,
    type,
    area_sqkm
FROM public_data.osm_landuse
ORDER BY area_sqkm DESC
LIMIT 10;
")
```

## Summary

```{r}
# Final statistics
dbGetQuery(con, "
SELECT
    COUNT(*) as total_polygons,
    COUNT(DISTINCT class) as unique_classes,
    COUNT(DISTINCT type) as unique_types,
    ROUND(SUM(area_sqkm)::numeric, 2) as total_area_sqkm,
    COUNT(geom) as polygons_with_geometry
FROM public_data.osm_landuse;
")
```

## Load ADI Data

This section loads Area Deprivation Index (ADI) scores by census block group for Wisconsin. ADI data comes from two sources that are joined in R:

**Source 1:** Wisconsin census block group geometries (shapefile)
**Source 2:** NaNDA standardized ADI scores 2020 (CSV)
**Target:** `public_data.adi_scores`
**Expected:** ~4,600 block groups (Wisconsin only)

### Load Wisconsin Census Block Group Geometries

```{r}
# Path to Wisconsin TIGER 2020 block groups
tiger_path <- str_c(path_gps2, "/adi/wisconsin_block_groups_2020.shp")

wi_geometries <- st_read(tiger_path) |>
  st_make_valid() |>
  st_transform(4326) |>
  select(fips_2020 = GEOID, geometry) |>
  mutate(area_sqm = as.numeric(st_area(geometry)))

nrow(wi_geometries)
```

### Load NaNDA Standardized ADI Scores

```{r}
# Path to ADI scores CSV
adi_path <- str_c(path_gps2, "/adi/adi_scores_nanda_standardized_2020.csv")

adi_scores <- read_csv(adi_path, show_col_types = FALSE) |>
  filter(state_postal == "WI") |>
  select(
    fips_2020 = blkgrp_fips20,
    state_postal,
    adi_national_percentile = adistd_ntl,
    adi_state_decile = adistd_state
  )

nrow(adi_scores)
```

### Join Geometries with ADI Scores

```{r}
# Inner join to combine geometry and ADI data
adi_data <- wi_geometries |>
  inner_join(adi_scores, by = "fips_2020") |>
  mutate(geometry = st_cast(geometry, "MULTIPOLYGON"))

nrow(adi_data)
```

```{r}
# Calculate join rate
round(nrow(adi_data) / nrow(wi_geometries) * 100, 1)
```

### Preview Data

```{r}
# Show structure
glimpse(adi_data)
```

```{r}
# Sample records
adi_data |>
  slice_head(n = 10) |>
  st_drop_geometry() |>
  select(fips_2020, state_postal, adi_national_percentile, adi_state_decile, area_sqm)
```

```{r}
# ADI distribution
adi_data |>
  st_drop_geometry() |>
  summarise(
    min_adi = min(adi_national_percentile, na.rm = TRUE),
    q25_adi = quantile(adi_national_percentile, 0.25, na.rm = TRUE),
    median_adi = median(adi_national_percentile, na.rm = TRUE),
    q75_adi = quantile(adi_national_percentile, 0.75, na.rm = TRUE),
    max_adi = max(adi_national_percentile, na.rm = TRUE)
  )
```

### Write to Database

```{r}
# Write to public_data.adi_scores
st_write(adi_data,
         con,
         Id(schema = "public_data", table = "adi_scores"),
         append = FALSE)
```

### Verify Load

```{r}
# Check row count
dbGetQuery(con, "SELECT COUNT(*) as row_count FROM public_data.adi_scores")
```

```{r}
# Check ADI distribution
dbGetQuery(con, "
SELECT
    MIN(adi_national_percentile) as min_adi,
    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY adi_national_percentile) as q25_adi,
    PERCENTILE_CONT(0.50) WITHIN GROUP (ORDER BY adi_national_percentile) as median_adi,
    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY adi_national_percentile) as q75_adi,
    MAX(adi_national_percentile) as max_adi
FROM public_data.adi_scores;
")
```

```{r}
# Sample high and low ADI areas
dbGetQuery(con, "
(SELECT 'High Deprivation' as category, fips_2020, adi_national_percentile, adi_state_decile
 FROM public_data.adi_scores
 ORDER BY adi_national_percentile DESC
 LIMIT 5)
UNION ALL
(SELECT 'Low Deprivation' as category, fips_2020, adi_national_percentile, adi_state_decile
 FROM public_data.adi_scores
 ORDER BY adi_national_percentile ASC
 LIMIT 5);
")
```

### Summary

```{r}
# Final statistics
dbGetQuery(con, "
SELECT
    COUNT(*) as total_block_groups,
    COUNT(adi_national_percentile) as with_adi_score,
    ROUND(AVG(adi_national_percentile)::numeric, 1) as avg_adi,
    ROUND(AVG(area_sqm)::numeric, 2) as avg_area_sqm,
    COUNT(geometry) as with_geometry
FROM public_data.adi_scores;
")
```

## Cleanup

```{r}
disconnect_db(con)
```
