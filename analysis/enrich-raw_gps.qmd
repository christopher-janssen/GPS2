---
title: "Enrich GPS Data with Spatial Context"
author: "Christopher Janssen"
date: "`r lubridate::today()`"
format:
  html:
    self-contained: true
editor_options:
  chunk_output_type: console
editor:
  markdown:
    wrap: 72
---

# GPS Data Enrichment

This notebook enriches GPS data with spatial context from the database:

-   **ADI scores**: Census block group deprivation index
-   **POI proximity**: Evidence-based categories for lapse prediction
    - Alcohol venues (on-premise): bars, pubs, nightclubs
    - Alcohol retail (off-premise): liquor stores, alcohol shops
    - Recovery facilities: treatment centers, sober living

**POI Distance Limit:** 100 meters (captures direct visits + immediate nearby exposure)

**Analysis approach:** Point-level enrichment → time-weighted aggregation → subject-level features

## Setup

```{r include=FALSE}
source(here::here("scripts/r/setup.R"))
source(here::here("scripts/r/connection.R"))

# Connect to database
con <- connect_to_db()
```

## Load GPS Data

```{r}
# Filepath
gps_path <- str_c(path_shared, "/gps_enriched.csv")

# read data
gps_data <- read_csv(gps_path, show_col_types = FALSE)

nrow(gps_data)
```

```{r}
glimpse(gps_data)
```

## POI Availability Check

**Purpose:** Verify that POI categories exist in our study area before running
expensive spatial queries. Check both database-wide availability and spatial
overlap with GPS coverage area.

### POI Counts by Target Category

```{r}
# Count POI by our target categories
poi_availability <- dbGetQuery(con, "
SELECT
  CASE
    WHEN class = 'amenity' AND type IN ('bar', 'pub', 'nightclub', 'biergarten')
      THEN 'alcohol_venue'
    WHEN (class = 'shop' AND type IN ('alcohol', 'wine'))
      OR (class = 'craft' AND type = 'brewery')
      THEN 'alcohol_retail'
    WHEN (class = 'amenity' AND type = 'social_facility')
      OR (class = 'healthcare' AND type IN ('clinic', 'centre'))
      THEN 'recovery_facility'
    ELSE 'other'
  END as poi_category,
  COUNT(*) as n_poi
FROM public_data.osm_poi
GROUP BY poi_category
ORDER BY n_poi DESC;
")

poi_availability
```

### Detailed Breakdown by Type

**Alcohol Venues:**

```{r}
dbGetQuery(con, "
SELECT type, COUNT(*) as count
FROM public_data.osm_poi
WHERE class = 'amenity'
  AND type IN ('bar', 'pub', 'nightclub', 'biergarten')
GROUP BY type
ORDER BY count DESC;
")
```

**Alcohol Retail:**

```{r}
dbGetQuery(con, "
SELECT class, type, COUNT(*) as count
FROM public_data.osm_poi
WHERE (class = 'shop' AND type IN ('alcohol', 'wine'))
   OR (class = 'craft' AND type = 'brewery')
GROUP BY class, type
ORDER BY count DESC;
")
```

**Recovery Facilities:**

```{r}
dbGetQuery(con, "
SELECT class, type, COUNT(*) as count
FROM public_data.osm_poi
WHERE (class = 'amenity' AND type = 'social_facility')
   OR (class = 'healthcare' AND type IN ('clinic', 'centre'))
GROUP BY class, type
ORDER BY count DESC;
")
```

### Spatial Coverage Check

Check if POI are distributed within our GPS coverage area (bounding box).

```{r}
# Sample GPS points to create bounding box (use 10k points for speed)
gps_distinct <- gps_data |>
  distinct(lat, lon)

gps_sample <- gps_distinct |>
  slice_sample(n = min(10000, nrow(gps_distinct)))

# Write sample to temp table
dbWriteTable(con, "temp_gps_sample", gps_sample, temporary = TRUE, overwrite = TRUE, row.names = FALSE)

# Create geometries
dbExecute(con, "
ALTER TABLE temp_gps_sample
ADD COLUMN geom GEOMETRY(Point, 4326);
")

dbExecute(con, "
UPDATE temp_gps_sample
SET geom = ST_SetSRID(ST_MakePoint(lon, lat), 4326);
")
```

```{r}
# Count POI within GPS bounding box
spatial_coverage <- dbGetQuery(con, "
WITH gps_bbox AS (
  SELECT ST_SetSRID(ST_Extent(geom), 4326) as bbox
  FROM temp_gps_sample
)
SELECT
  'Alcohol Venues' as category,
  COUNT(*) as poi_in_study_area
FROM public_data.osm_poi, gps_bbox
WHERE class = 'amenity'
  AND type IN ('bar', 'pub', 'nightclub', 'biergarten')
  AND ST_Intersects(geom, bbox)

UNION ALL

SELECT
  'Alcohol Retail' as category,
  COUNT(*) as poi_in_study_area
FROM public_data.osm_poi, gps_bbox
WHERE ((class = 'shop' AND type IN ('alcohol', 'wine'))
    OR (class = 'craft' AND type = 'brewery'))
  AND ST_Intersects(geom, bbox)

UNION ALL

SELECT
  'Recovery Facilities' as category,
  COUNT(*) as poi_in_study_area
FROM public_data.osm_poi, gps_bbox
WHERE ((class = 'amenity' AND type = 'social_facility')
    OR (class = 'healthcare' AND type IN ('clinic', 'centre')))
  AND ST_Intersects(geom, bbox);
")

spatial_coverage
```

```{r}
# Clean up temp sample table
dbExecute(con, "DROP TABLE IF EXISTS temp_gps_sample;")
```

**Interpretation:**
- Count = 0 → Category doesn't exist, skip enrichment
- Count < 10 → Sparse coverage, likely few matches
- Count > 100 → Good coverage, expect meaningful matches

## Load GPS Points into Temporary Database Table

For efficient spatial queries, we'll load GPS points into a temporary
database table with PostGIS geometries.

```{r}
# Select minimal columns needed for spatial joins
gps_spatial <- gps_data |>
  mutate(row_id = row_number()) |>
  select(row_id, lat, lon)
```

```{r}
# Write to temporary table
dbWriteTable(con, "temp_gps_points", gps_spatial, temporary = TRUE, overwrite = TRUE, row.names = FALSE)
```

This is basically the R equivalent of loading a dataset into the
environment. We want it to be available and ready for analyses quickly,
but not permanently.

```{r}
# Create geometry column
dbExecute(con, "
ALTER TABLE temp_gps_points
ADD COLUMN geom GEOMETRY(Point, 4326);
")

dbExecute(con, "
UPDATE temp_gps_points
SET geom = ST_SetSRID(ST_MakePoint(lon, lat), 4326);
")
```

`GEOMETRY(Point, 4326)` defines two major things:

1.  Point = Geometry Type

Specifies what kind of spatial object we are storing.

Options include:

-   Point (single location, like GPS coords)

-   LineString - A connected path (route)

-   Polygon - enclosed area (census block groups/landuse)

-   Multipoint, MultiPolygon, etc

2.  4326 = **SRID** (Spatial Reference System Identifier)

Specifies what coordinate system, and how to interpret the lat/lon
numbers.

This project uses **EPSG:4326 / WGS84**

They both refer to the same thing: 

-   WGS84 = "World Geodetic System 1984" 
-   EPSG:4326 = The code number for it from the EPSG registry

WGS84 is the coordinate system GPS satellites use:

-   Uses degrees (not meters/feet)

-   Covers the whole Earth

-   Good for storage and display

But notably **not suited for distance calculations**:

In Madison, Wisconsin's latitude (\~43°) - 1° lon = \~80km - 1° lat =
\~111km

At the equator: - 1° lon = \~ 111km - 1° lat = \~ 111km

The solution:

```{r}
# ST_MakePoint(lon, lat)  Creates a point 
# ST_SetSRID(..., 4326)   Tag it: "These are WGS84 lat/lon degrees"
```

Now PostGIS knows:

-   These are degrees, not meters

-   These points need to be converted to geography for accurate meter-based distances

-   Spatial indexes can be used to optimize this lat/lon data

Why Transform to Geometry Type?

-   PostGIS spatial indexes make "nearest neighbor" queries feasible.

-   Without spatial indexes, finding the nearest POI would require 1.24M GPS points × 85K POI = 105 billion distance calculations

Why can't we use those fancy spatial indexes on the lat/lons?

PostgreSQL's GIST indexes require a single column. The geometry type
packages both coordinates into one column, enabling spatial indexing.
You cannot create a GIST spatial index on `(lat, lon)` as separate
columns.

Use-case:

Queries will use both geometry and geography types: 

-   `geometry` when fast operations in degrees are necessary 

-   `geography` when accurate calculations in meters are necessary

```{r}
# Create spatial index for performance
dbExecute(con, "
CREATE INDEX idx_temp_gps_geom ON temp_gps_points USING GIST(geom);
")

# Create index on row_id for join performance
dbExecute(con, "
CREATE INDEX idx_temp_gps_row_id ON temp_gps_points(row_id);
")

# Update table statistics so query planner uses indexes
dbExecute(con, "ANALYZE temp_gps_points;")
```

```{r}
# Verify
dbGetQuery(con, "
SELECT COUNT(*) as total_points, COUNT(geom) as with_geometry
FROM temp_gps_points;
")
```

## Enrich with ADI Scores

Spatial join to match GPS points with census block group ADI scores.

```{r}
# Spatial join: point-in-polygon
#
# R-equivalent logic:
#   gps_data |>
#     left_join(adi_scores, by = st_within(gps_point, adi_polygon))
#
# SQL Explanation:
#   - LEFT JOIN: Keep all GPS points, even if no ADI match (R: left_join)
#   - ST_Within: Check if GPS point falls inside ADI polygon (R: st_within)

adi_results <- dbGetQuery(con, "
SELECT
    t.row_id,
    a.fips_2020,
    a.adi_national_percentile,
    a.adi_state_decile
FROM temp_gps_points t
LEFT JOIN public_data.adi_scores a
    ON ST_Within(t.geom, a.geometry)
ORDER BY t.row_id;
")

nrow(adi_results)
```

```{r}
# Check match rate
adi_results |>
  summarise(
    total_points = n(),
    with_adi = sum(!is.na(adi_national_percentile)),
    match_rate = round(sum(!is.na(adi_national_percentile)) / n() * 100, 2)
  )
```

## Enrich with Evidence-Based POI Categories

**Purpose:** Theory-driven POI selection for time-weighted individual-level lapse prediction.

**Why these 3 categories?**
- **HIGH tier evidence** from addiction research literature
- **Minimal feature set** for N=167 subjects (56 obs/feature after aggregation)
- Capture both **risky** (alcohol exposure) and **protective** (recovery access) factors

**Distance threshold:** 100 meters captures both:
- Direct visits (20-50m): Person is AT the POI
- Immediate exposure (50-100m): POI in walkable environment

**Downstream aggregation:** These distance measures will be aggregated to subject-level
features for time-weighted lapse prediction (e.g., % time near alcohol venues, mean
distance to recovery facilities).

**Source:** Evidence synthesis from addiction research, environmental epidemiology,
and CDC alcohol outlet measurement standards. See research_POI.md for full citations.

### How the POI Queries Work

**R-Equivalent Logic:**

``` r
# For each GPS point, find nearest POI of specific type within 100m
gps_data |>
  group_by(row_id) |>
  mutate(
    nearest_alcohol_venue_distance = find_closest_poi(this_point, alcohol_venues, max_dist = 100)
  ) |>
  filter(distance <= 100) |>
  slice_head(n = 1)
```

**SQL Pattern:**

- `CROSS JOIN LATERAL`: For each GPS point, search POI table
- `ORDER BY poi.geom <-> gps.geom`: Use spatial index for fast nearest-neighbor
- `ST_DWithin(..., 100)`: Pre-filter to 100m radius
- `DISTINCT ON (gps.row_id)`: Return only nearest match per GPS point
- `::geography`: Accurate meter-based distance (not degrees)

### Nearest Alcohol Venue (On-Premise)

Bars, pubs, nightclubs, biergartens.

**Evidence tier:** HIGH relevance - risky exposure

```{r}
# Same optimization pattern: geometry for sorting, geography for validation
nearest_alcohol_venue <- dbGetQuery(con, "
SELECT DISTINCT ON (gps.row_id)
    gps.row_id,
    poi.type as nearest_alcohol_venue_type,
    ROUND(ST_Distance(gps.geom::geography, poi.geom::geography)::numeric, 2) as nearest_alcohol_venue_distance_m
FROM temp_gps_points gps
CROSS JOIN LATERAL (
    SELECT type, geom
    FROM public_data.osm_poi poi
    WHERE poi.class = 'amenity'
      AND poi.type IN ('bar', 'pub', 'nightclub', 'biergarten')
    ORDER BY poi.geom <-> gps.geom
    LIMIT 5
) poi
WHERE ST_DWithin(poi.geom::geography, gps.geom::geography, 100)
ORDER BY gps.row_id, poi.geom <-> gps.geom;
")

nrow(nearest_alcohol_venue)
```

### Nearest Alcohol Retail (Off-Premise)

Liquor stores, wine shops, breweries.

**Evidence tier:** HIGH relevance - risky exposure

```{r}
# Same optimization pattern: geometry for sorting, geography for validation
nearest_alcohol_retail <- dbGetQuery(con, "
SELECT DISTINCT ON (gps.row_id)
    gps.row_id,
    CASE
        WHEN poi.class = 'shop' THEN poi.type
        WHEN poi.class = 'craft' THEN 'brewery'
    END as nearest_alcohol_retail_type,
    ROUND(ST_Distance(gps.geom::geography, poi.geom::geography)::numeric, 2) as nearest_alcohol_retail_distance_m
FROM temp_gps_points gps
CROSS JOIN LATERAL (
    SELECT class, type, geom
    FROM public_data.osm_poi poi
    WHERE ((poi.class = 'shop' AND poi.type IN ('alcohol', 'wine'))
           OR (poi.class = 'craft' AND poi.type = 'brewery'))
    ORDER BY poi.geom <-> gps.geom
    LIMIT 5
) poi
WHERE ST_DWithin(poi.geom::geography, gps.geom::geography, 100)
ORDER BY gps.row_id, poi.geom <-> gps.geom;
")

nrow(nearest_alcohol_retail)
```

### Nearest Recovery Facility

Treatment centers, sober living homes, outpatient clinics.

**Evidence tier:** HIGH relevance - protective exposure

**Note:** OSM coverage for recovery facilities is limited. Consider supplementing
with SAMHSA treatment locator or state behavioral health directories.

```{r}
# Same optimization pattern: geometry for sorting, geography for validation
nearest_recovery <- dbGetQuery(con, "
SELECT DISTINCT ON (gps.row_id)
    gps.row_id,
    poi.type as nearest_recovery_type,
    ROUND(ST_Distance(gps.geom::geography, poi.geom::geography)::numeric, 2) as nearest_recovery_distance_m
FROM temp_gps_points gps
CROSS JOIN LATERAL (
    SELECT type, geom
    FROM public_data.osm_poi poi
    WHERE (poi.class = 'amenity' AND poi.type = 'social_facility')
       OR (poi.class = 'healthcare' AND poi.type IN ('clinic', 'centre'))
    ORDER BY poi.geom <-> gps.geom
    LIMIT 5
) poi
WHERE ST_DWithin(poi.geom::geography, gps.geom::geography, 100)
ORDER BY gps.row_id, poi.geom <-> gps.geom;
")

nrow(nearest_recovery)
```

## Join All Enrichments

```{r}
# Start with original GPS data and add row_id
gps_enriched <- gps_data |>
  mutate(row_id = row_number())

# Join ADI data
gps_enriched <- gps_enriched |>
  left_join(adi_results, by = "row_id")

# Join HIGH tier POI categories (3 total)
gps_enriched <- gps_enriched |>
  left_join(nearest_alcohol_venue, by = "row_id") |>
  left_join(nearest_alcohol_retail, by = "row_id") |>
  left_join(nearest_recovery, by = "row_id")

# Remove temporary row_id
gps_enriched <- gps_enriched |>
  select(-row_id)

nrow(gps_enriched)
```

## Summary Statistics

### ADI Coverage

```{r}
gps_enriched |>
  summarise(
    total_points = n(),
    with_adi = sum(!is.na(adi_national_percentile)),
    match_rate_pct = round(sum(!is.na(adi_national_percentile)) / n() * 100, 2)
  ) |>
  knitr::kable()
```

### POI Coverage (HIGH Tier Only)

```{r}
tibble(
  category = c("Alcohol Venue (on-premise)",
               "Alcohol Retail (off-premise)",
               "Recovery Facilities"),
  type = c("Risky", "Risky", "Protective"),
  matches = c(
    sum(!is.na(gps_enriched$nearest_alcohol_venue_type)),
    sum(!is.na(gps_enriched$nearest_alcohol_retail_type)),
    sum(!is.na(gps_enriched$nearest_recovery_type))
  ),
  match_rate_pct = round(matches / nrow(gps_enriched) * 100, 2)
) |>
  knitr::kable()
```

### POI Type Distribution

**Alcohol Venues (on-premise):**

```{r}
gps_enriched |>
  filter(!is.na(nearest_alcohol_venue_type)) |>
  count(nearest_alcohol_venue_type, sort = TRUE) |>
  knitr::kable()
```

**Alcohol Retail (off-premise):**

```{r}
gps_enriched |>
  filter(!is.na(nearest_alcohol_retail_type)) |>
  count(nearest_alcohol_retail_type, sort = TRUE) |>
  knitr::kable()
```

**Recovery Facilities:**

```{r}
gps_enriched |>
  filter(!is.na(nearest_recovery_type)) |>
  count(nearest_recovery_type, sort = TRUE) |>
  knitr::kable()
```

## Write Enriched Data

```{r}
# Output path
output_path <- str_c(path_shared, "/gps_enriched_all.csv")

# Write enriched data
write_csv(gps_enriched, output_path)
```

```{r}
# Verify file was written
file.info(output_path)$size / 1024^2  # Size in MB
```

## Cleanup

```{r}
# Drop temporary table
dbExecute(con, "DROP TABLE IF EXISTS temp_gps_points;")

# Disconnect
disconnect_db(con)
```
