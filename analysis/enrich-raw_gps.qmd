---
title: "Enrich GPS Data with Spatial Context"
author: "Christopher Janssen"
date: "`r lubridate::today()`"
format:
  html:
    self-contained: true
editor_options:
  chunk_output_type: console
editor:
  markdown:
    wrap: 72
---

# GPS Data Enrichment

This notebook enriches GPS data with spatial context from the database:

-   **ADI scores**: Census block group deprivation index
-   **Nearest POI**: Hierarchical matching to OpenStreetMap points of
    interest

**POI Distance Limit:** 20 meters

## Setup

```{r include=FALSE}
source(here::here("scripts/r/setup.R"))
source(here::here("scripts/r/connection.R"))

# Connect to database
con <- connect_to_db()
```

## Load GPS Data

```{r}
# Filepath
gps_path <- str_c(path_shared, "/gps_enriched.csv")

# read data
gps_data <- read_csv(gps_path, show_col_types = FALSE)

nrow(gps_data)
```

```{r}
glimpse(gps_data)
```

## Load GPS Points into Temporary Database Table

For efficient spatial queries, we'll load GPS points into a temporary
database table with PostGIS geometries.

```{r}
# Select minimal columns needed for spatial joins
gps_spatial <- gps_data |>
  mutate(row_id = row_number()) |>
  select(row_id, lat, lon)
```

```{r}
# Write to temporary table
dbWriteTable(con, "temp_gps_points", gps_spatial, temporary = TRUE, overwrite = TRUE, row.names = FALSE)
```

This is basically the R equivalent of loading a dataset into the
environment. We want it to be available and ready for analyses quickly,
but not permanently.

```{r}
# Create geometry column
dbExecute(con, "
ALTER TABLE temp_gps_points
ADD COLUMN geom GEOMETRY(Point, 4326);
")

dbExecute(con, "
UPDATE temp_gps_points
SET geom = ST_SetSRID(ST_MakePoint(lon, lat), 4326);
")
```

`GEOMETRY(Point, 4326)` defines two major things:

1.  Point = Geometry Type

Specifies what kind of spatial object we are storing.

Options include:

-   Point (single location, like GPS coords)

-   LineString - A connected path (route)

-   Polygon - enclosed area (census block groups/landuse)

-   Multipoint, MultiPolygon, etc

2.  4326 = **SRID** (Spatial Reference System Identifier)

Specifies what coordinate system, and how to interpret the lat/lon
numbers.

This project uses **EPSG:4326 / WGS84**

They both refer to the same thing: 

-   WGS84 = "World Geodetic System 1984" 
-   EPSG:4326 = The code number for it from the EPSG registry

WGS84 is the coordinate system GPS satellites use:

-   Uses degrees (not meters/feet)

-   Covers the whole Earth

-   Good for storage and display

But notably **not suited for distance calculations**:

In Madison, Wisconsin's latitude (\~43°) - 1° lon = \~80km - 1° lat =
\~111km

At the equator: - 1° lon = \~ 111km - 1° lat = \~ 111km

The solution:

```{r}
ST_MakePoint(lon, lat) # Creates a point 
ST_SetSRID(..., 4326) # Tag it: "These are WGS84 lat/lon degrees"
```

Now PostGIS knows:

-   These are degrees, not meters

-   These points need to be converted to geography for accurate meter-based distances

-   Spatial indexes can be used to optimize this lat/lon data

Why Transform to Geometry Type?

-   PostGIS spatial indexes make "nearest neighbor" queries feasible.

-   Without spatial indexes, finding the nearest POI would require 1.24M GPS points × 85K POI = 105 billion distance calculations

Why can't we use those fancy spatial indexes on the lat/lons?

PostgreSQL's GIST indexes require a single column. The geometry type
packages both coordinates into one column, enabling spatial indexing.
You cannot create a GIST spatial index on `(lat, lon)` as separate
columns.

Use-case:

Queries will use both geometry and geography types: 

-   `geometry` when fast operations in degrees are necessary 

-   `geography` when accurate calculations in meters are necessary

```{r}
# Create spatial index for performance
dbExecute(con, "
CREATE INDEX idx_temp_gps_geom ON temp_gps_points USING GIST(geom);
")

# Create index on row_id for join performance
dbExecute(con, "
CREATE INDEX idx_temp_gps_row_id ON temp_gps_points(row_id);
")

# Update table statistics so query planner uses indexes
dbExecute(con, "ANALYZE temp_gps_points;")
```

```{r}
# Verify
dbGetQuery(con, "
SELECT COUNT(*) as total_points, COUNT(geom) as with_geometry
FROM temp_gps_points;
")
```

## Enrich with ADI Scores

Spatial join to match GPS points with census block group ADI scores.

```{r}
# Spatial join: point-in-polygon
#
# R-equivalent logic:
#   gps_data |>
#     left_join(adi_scores, by = st_within(gps_point, adi_polygon))
#
# SQL Explanation:
#   - LEFT JOIN: Keep all GPS points, even if no ADI match (R: left_join)
#   - ST_Within: Check if GPS point falls inside ADI polygon (R: st_within)

adi_results <- dbGetQuery(con, "
SELECT
    t.row_id,
    a.fips_2020,
    a.adi_national_percentile,
    a.adi_state_decile
FROM temp_gps_points t
LEFT JOIN public_data.adi_scores a
    ON ST_Within(t.geom, a.geometry)
ORDER BY t.row_id;
")

nrow(adi_results)
```

```{r}
# Check match rate
adi_results |>
  summarise(
    total_points = n(),
    with_adi = sum(!is.na(adi_national_percentile)),
    match_rate = round(sum(!is.na(adi_national_percentile)) / n() * 100, 2)
  )
```

## Enrich with Nearest POI

### How the POI Queries Work

The POI enrichment queries find the nearest point of interest within 20
meters for each GPS point. Here's how they work:

**R-Equivalent Logic:**

``` r
# What we're doing in R terms:
gps_data |>
  group_by(row_id) |>
  mutate(
    nearest_poi = find_closest_poi(this_point, all_poi, max_dist = 20)
  ) |>
  filter(distance <= 20) |>
  slice_head(n = 1)  # Keep only the nearest match
```

**SQL Pattern Explanation:**

1.  **`CROSS JOIN LATERAL`** = "For each GPS point, run this subquery"
    -   Like a nested loop or `map()` function
    -   Lets us search POI table for each GPS row independently
2.  **`DISTINCT ON (gps.row_id)`** = "Keep only the first match per GPS
    point"
    -   R equivalent: `group_by(row_id) |> slice_head(n = 1)`
    -   Ensures we get exactly one result per GPS point (or zero if no
        match)
3.  **`ORDER BY poi.geom <-> gps.geom`** = "Sort by nearest distance
    using spatial index"
    -   The `<->` operator is PostGIS's fast distance operator
    -   Uses spatial indexes for extremely fast lookup (milliseconds per
        point)
    -   R equivalent: `arrange(distance)` but optimized
4.  **`ST_DWithin(..., 20)`** = "Only consider POI within 20 meters"
    -   Pre-filters POI before distance calculation
    -   R equivalent: `filter(distance <= 20)`
5.  **`::geography`** = "Use accurate meter-based distance on Earth's
    surface"
    -   Converts from degrees to true meters
    -   R equivalent: transforming to a projected CRS
6.  **`LIMIT 1`** = "Return only the nearest POI for this GPS point"
    -   Combined with ORDER BY, gets the closest match

### Nearest POI - Overall

Find nearest POI of any type (excluding noise categories) within 20m.

```{r}
# Define noise types to exclude
noise_filter <- "
WHERE poi.class NOT IN ('man_made', 'natural', 'military', 'emergency', 'healthcare')
  AND poi.type NOT IN ('parking', 'bench', 'bicycle_parking', 'shelter',
                       'waste_basket', 'toilets', 'loading_dock', 'waste_disposal',
                       'drinking_water', 'grave_yard')
"
```

```{r}
# Find nearest POI within 20m
#
# Query breakdown:
#   1. For each GPS point (CROSS JOIN LATERAL)
#   2. Fast geometric pre-filter using <-> operator and index
#   3. Accurate geography distance check (only on nearest candidates)
#   4. Keep only nearest within 20m (LIMIT 1)
#   5. Return one result per GPS point (DISTINCT ON)
#
# Performance optimization:
#   - Uses geometry (fast, indexed) for initial sorting
#   - Only converts to geography for final distance validation
#   - At Wisconsin latitude (~43°), 20m ≈ 0.00018 degrees

nearest_poi <- dbGetQuery(con, str_c("
SELECT DISTINCT ON (gps.row_id)
    gps.row_id,
    poi.class as nearest_poi_class,
    poi.type as nearest_poi_type,
    ROUND(ST_Distance(gps.geom::geography, poi.geom::geography)::numeric, 2) as nearest_poi_distance_m
FROM temp_gps_points gps
CROSS JOIN LATERAL (
    SELECT class, type, geom
    FROM public_data.osm_poi poi
    ", noise_filter, "
    ORDER BY poi.geom <-> gps.geom
    LIMIT 5
) poi
WHERE ST_DWithin(poi.geom::geography, gps.geom::geography, 20)
ORDER BY gps.row_id, poi.geom <-> gps.geom;
"))

nrow(nearest_poi)
```

```{r}
# Check match rate
tibble(
  total_points = nrow(gps_data),
  with_nearest_poi = nrow(nearest_poi),
  match_rate = round(nrow(nearest_poi) / nrow(gps_data) * 100, 2)
)
```

## Enrich with Nearest POI by Major Class

Find nearest POI within each major class (shop, amenity, leisure,
tourism).

**Note:** These queries follow the same pattern as above, but filter to
specific POI classes.

### Nearest Shop

```{r}
# Same optimization pattern: geometry for sorting, geography for validation
nearest_shop <- dbGetQuery(con, "
SELECT DISTINCT ON (gps.row_id)
    gps.row_id,
    poi.type as nearest_shop_type,
    ROUND(ST_Distance(gps.geom::geography, poi.geom::geography)::numeric, 2) as nearest_shop_distance_m
FROM temp_gps_points gps
CROSS JOIN LATERAL (
    SELECT type, geom
    FROM public_data.osm_poi poi
    WHERE poi.class = 'shop'
    ORDER BY poi.geom <-> gps.geom
    LIMIT 5
) poi
WHERE ST_DWithin(poi.geom::geography, gps.geom::geography, 20)
ORDER BY gps.row_id, poi.geom <-> gps.geom;
")

nrow(nearest_shop)
```

### Nearest Amenity

```{r}
# Same optimization pattern: geometry for sorting, geography for validation
nearest_amenity <- dbGetQuery(con, "
SELECT DISTINCT ON (gps.row_id)
    gps.row_id,
    poi.type as nearest_amenity_type,
    ROUND(ST_Distance(gps.geom::geography, poi.geom::geography)::numeric, 2) as nearest_amenity_distance_m
FROM temp_gps_points gps
CROSS JOIN LATERAL (
    SELECT type, geom
    FROM public_data.osm_poi poi
    WHERE poi.class = 'amenity'
      AND poi.type NOT IN ('parking', 'bench', 'bicycle_parking', 'shelter',
                           'waste_basket', 'toilets', 'loading_dock', 'waste_disposal',
                           'drinking_water', 'grave_yard')
    ORDER BY poi.geom <-> gps.geom
    LIMIT 5
) poi
WHERE ST_DWithin(poi.geom::geography, gps.geom::geography, 20)
ORDER BY gps.row_id, poi.geom <-> gps.geom;
")

nrow(nearest_amenity)
```

### Nearest Leisure

```{r}
# Same optimization pattern: geometry for sorting, geography for validation
nearest_leisure <- dbGetQuery(con, "
SELECT DISTINCT ON (gps.row_id)
    gps.row_id,
    poi.type as nearest_leisure_type,
    ROUND(ST_Distance(gps.geom::geography, poi.geom::geography)::numeric, 2) as nearest_leisure_distance_m
FROM temp_gps_points gps
CROSS JOIN LATERAL (
    SELECT type, geom
    FROM public_data.osm_poi poi
    WHERE poi.class = 'leisure'
    ORDER BY poi.geom <-> gps.geom
    LIMIT 5
) poi
WHERE ST_DWithin(poi.geom::geography, gps.geom::geography, 20)
ORDER BY gps.row_id, poi.geom <-> gps.geom;
")

nrow(nearest_leisure)
```

### Nearest Tourism

```{r}
# Same optimization pattern: geometry for sorting, geography for validation
nearest_tourism <- dbGetQuery(con, "
SELECT DISTINCT ON (gps.row_id)
    gps.row_id,
    poi.type as nearest_tourism_type,
    ROUND(ST_Distance(gps.geom::geography, poi.geom::geography)::numeric, 2) as nearest_tourism_distance_m
FROM temp_gps_points gps
CROSS JOIN LATERAL (
    SELECT type, geom
    FROM public_data.osm_poi poi
    WHERE poi.class = 'tourism'
    ORDER BY poi.geom <-> gps.geom
    LIMIT 5
) poi
WHERE ST_DWithin(poi.geom::geography, gps.geom::geography, 20)
ORDER BY gps.row_id, poi.geom <-> gps.geom;
")

nrow(nearest_tourism)
```

## Enrich with Risk-Relevant POI Categories

**Note:** These queries use the same pattern, but filter to
research-relevant POI types.

### Nearest Alcohol Venue (On-Premise)

Bars, pubs, nightclubs, biergartens.

```{r}
# Same optimization pattern: geometry for sorting, geography for validation
nearest_alcohol_venue <- dbGetQuery(con, "
SELECT DISTINCT ON (gps.row_id)
    gps.row_id,
    poi.type as nearest_alcohol_venue_type,
    ROUND(ST_Distance(gps.geom::geography, poi.geom::geography)::numeric, 2) as nearest_alcohol_venue_distance_m
FROM temp_gps_points gps
CROSS JOIN LATERAL (
    SELECT type, geom
    FROM public_data.osm_poi poi
    WHERE poi.class = 'amenity'
      AND poi.type IN ('bar', 'pub', 'nightclub', 'biergarten')
    ORDER BY poi.geom <-> gps.geom
    LIMIT 5
) poi
WHERE ST_DWithin(poi.geom::geography, gps.geom::geography, 20)
ORDER BY gps.row_id, poi.geom <-> gps.geom;
")

nrow(nearest_alcohol_venue)
```

### Nearest Alcohol Retail (Off-Premise)

Liquor stores, wine shops, breweries.

```{r}
# Same optimization pattern: geometry for sorting, geography for validation
nearest_alcohol_retail <- dbGetQuery(con, "
SELECT DISTINCT ON (gps.row_id)
    gps.row_id,
    CASE
        WHEN poi.class = 'shop' THEN poi.type
        WHEN poi.class = 'craft' THEN 'brewery'
    END as nearest_alcohol_retail_type,
    ROUND(ST_Distance(gps.geom::geography, poi.geom::geography)::numeric, 2) as nearest_alcohol_retail_distance_m
FROM temp_gps_points gps
CROSS JOIN LATERAL (
    SELECT class, type, geom
    FROM public_data.osm_poi poi
    WHERE ((poi.class = 'shop' AND poi.type IN ('alcohol', 'wine'))
           OR (poi.class = 'craft' AND poi.type = 'brewery'))
    ORDER BY poi.geom <-> gps.geom
    LIMIT 5
) poi
WHERE ST_DWithin(poi.geom::geography, gps.geom::geography, 20)
ORDER BY gps.row_id, poi.geom <-> gps.geom;
")

nrow(nearest_alcohol_retail)
```

### Nearest Food Venue

Restaurants, cafes, fast food.

```{r}
# Same optimization pattern: geometry for sorting, geography for validation
nearest_food_venue <- dbGetQuery(con, "
SELECT DISTINCT ON (gps.row_id)
    gps.row_id,
    poi.type as nearest_food_venue_type,
    ROUND(ST_Distance(gps.geom::geography, poi.geom::geography)::numeric, 2) as nearest_food_venue_distance_m
FROM temp_gps_points gps
CROSS JOIN LATERAL (
    SELECT type, geom
    FROM public_data.osm_poi poi
    WHERE poi.class = 'amenity'
      AND poi.type IN ('restaurant', 'cafe', 'fast_food')
    ORDER BY poi.geom <-> gps.geom
    LIMIT 5
) poi
WHERE ST_DWithin(poi.geom::geography, gps.geom::geography, 20)
ORDER BY gps.row_id, poi.geom <-> gps.geom;
")

nrow(nearest_food_venue)
```

## Join All Enrichments

```{r}
# Start with original GPS data and add row_id
gps_enriched <- gps_data |>
  mutate(row_id = row_number())

# Join ADI data
gps_enriched <- gps_enriched |>
  left_join(adi_results, by = "row_id")

# Join overall nearest POI
gps_enriched <- gps_enriched |>
  left_join(nearest_poi, by = "row_id")

# Join nearest by class
gps_enriched <- gps_enriched |>
  left_join(nearest_shop, by = "row_id") |>
  left_join(nearest_amenity, by = "row_id") |>
  left_join(nearest_leisure, by = "row_id") |>
  left_join(nearest_tourism, by = "row_id")

# Join risk-specific categories
gps_enriched <- gps_enriched |>
  left_join(nearest_alcohol_venue, by = "row_id") |>
  left_join(nearest_alcohol_retail, by = "row_id") |>
  left_join(nearest_food_venue, by = "row_id")

# Remove temporary row_id
gps_enriched <- gps_enriched |>
  select(-row_id)

nrow(gps_enriched)
```

## Summary Statistics

### ADI Coverage

```{r}
gps_enriched |>
  summarise(
    total_points = n(),
    with_adi = sum(!is.na(adi_national_percentile)),
    match_rate_pct = round(sum(!is.na(adi_national_percentile)) / n() * 100, 2)
  ) |>
  knitr::kable()
```

### POI Coverage

```{r}
tibble(
  category = c("Overall POI", "Shop", "Amenity", "Leisure", "Tourism",
               "Alcohol Venue", "Alcohol Retail", "Food Venue"),
  matches = c(
    sum(!is.na(gps_enriched$nearest_poi_type)),
    sum(!is.na(gps_enriched$nearest_shop_type)),
    sum(!is.na(gps_enriched$nearest_amenity_type)),
    sum(!is.na(gps_enriched$nearest_leisure_type)),
    sum(!is.na(gps_enriched$nearest_tourism_type)),
    sum(!is.na(gps_enriched$nearest_alcohol_venue_type)),
    sum(!is.na(gps_enriched$nearest_alcohol_retail_type)),
    sum(!is.na(gps_enriched$nearest_food_venue_type))
  ),
  match_rate_pct = round(matches / nrow(gps_enriched) * 100, 2)
) |>
  knitr::kable()
```

### Risk-Relevant POI Distribution

```{r}
# Alcohol venue types
gps_enriched |>
  filter(!is.na(nearest_alcohol_venue_type)) |>
  count(nearest_alcohol_venue_type, sort = TRUE) |>
  knitr::kable()
```

```{r}
# Food venue types
gps_enriched |>
  filter(!is.na(nearest_food_venue_type)) |>
  count(nearest_food_venue_type, sort = TRUE) |>
  knitr::kable()
```

## Write Enriched Data

```{r}
# Output path
output_path <- str_c(path_shared, "/gps_enriched_all.csv")

# Write enriched data
write_csv(gps_enriched, output_path)
```

```{r}
# Verify file was written
file.info(output_path)$size / 1024^2  # Size in MB
```

## Cleanup

```{r}
# Drop temporary table
dbExecute(con, "DROP TABLE IF EXISTS temp_gps_points;")

# Disconnect
disconnect_db(con)
```
