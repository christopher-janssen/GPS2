---
title: "Enrich GPS Data with Spatial Context"
author: "Christopher Janssen"
date: "`r lubridate::today()`"
format:
  html:
    self-contained: true
editor_options:
  chunk_output_type: console
editor:
  markdown:
    wrap: 72
---

# GPS Data Enrichment

This notebook enriches GPS data with spatial context from the database:

-   **ADI scores**: Census block group deprivation index
-   **Nearest high-relevance POI**: Hierarchical matching for lapse prediction
    - Alcohol venues (on-premise): bars, pubs, nightclubs
    - Alcohol retail (off-premise): liquor stores, alcohol shops
    - Recovery facilities: treatment centers, sober living

**POI Matching:** Hierarchical - finds single nearest POI across all categories within 100m

**Distance Limit:** 100 meters (captures direct visits + immediate nearby exposure)

**Analysis approach:** Point-level enrichment → time-weighted aggregation → subject-level features

## Setup

```{r include=FALSE}
source(here::here("scripts/r/setup.R"))
source(here::here("scripts/r/connection.R"))

# Connect to database
con <- connect_to_db()
```

## Load GPS Data

```{r}
# Filepath
gps_path <- str_c(path_shared, "/gps_enriched.csv")

# read data
gps_data <- read_csv(gps_path, show_col_types = FALSE)

nrow(gps_data)
```

```{r}
glimpse(gps_data)
```

## POI Availability Check

**Purpose:** Verify that POI categories exist in our study area before running
expensive spatial queries. Check both database-wide availability and spatial
overlap with GPS coverage area.

### POI Counts by Target Category

```{r}
# Count POI by our target categories
poi_availability <- dbGetQuery(con, "
SELECT
  CASE
    WHEN class = 'amenity' AND type IN ('bar', 'pub', 'nightclub', 'biergarten')
      THEN 'alcohol_venue'
    WHEN (class = 'shop' AND type IN ('alcohol', 'wine'))
      OR (class = 'craft' AND type = 'brewery')
      THEN 'alcohol_retail'
    WHEN (class = 'amenity' AND type = 'social_facility')
      OR (class = 'healthcare' AND type IN ('clinic', 'centre'))
      THEN 'recovery_facility'
    ELSE 'other'
  END as poi_category,
  COUNT(*) as n_poi
FROM public_data.osm_poi
GROUP BY poi_category
ORDER BY n_poi DESC;
")

poi_availability
```

### Detailed Breakdown by Type

**Alcohol Venues:**

```{r}
dbGetQuery(con, "
SELECT type, COUNT(*) as count
FROM public_data.osm_poi
WHERE class = 'amenity'
  AND type IN ('bar', 'pub', 'nightclub', 'biergarten')
GROUP BY type
ORDER BY count DESC;
")
```

**Alcohol Retail:**

```{r}
dbGetQuery(con, "
SELECT class, type, COUNT(*) as count
FROM public_data.osm_poi
WHERE (class = 'shop' AND type IN ('alcohol', 'wine'))
   OR (class = 'craft' AND type = 'brewery')
GROUP BY class, type
ORDER BY count DESC;
")
```

**Recovery Facilities:**

```{r}
dbGetQuery(con, "
SELECT class, type, COUNT(*) as count
FROM public_data.osm_poi
WHERE (class = 'amenity' AND type = 'social_facility')
   OR (class = 'healthcare' AND type IN ('clinic', 'centre'))
GROUP BY class, type
ORDER BY count DESC;
")
```

### Spatial Coverage Check

Check if POI are distributed within our GPS coverage area (bounding box).

```{r}
# Sample GPS points to create bounding box (use 10k points for speed)
gps_distinct <- gps_data |>
  distinct(lat, lon)

gps_sample <- gps_distinct |>
  slice_sample(n = min(10000, nrow(gps_distinct)))

# Write sample to temp table
dbWriteTable(con, "temp_gps_sample", gps_sample, temporary = TRUE, overwrite = TRUE, row.names = FALSE)

# Create geometries
dbExecute(con, "
ALTER TABLE temp_gps_sample
ADD COLUMN geom GEOMETRY(Point, 4326);
")

dbExecute(con, "
UPDATE temp_gps_sample
SET geom = ST_SetSRID(ST_MakePoint(lon, lat), 4326);
")
```

```{r}
# Count POI within GPS bounding box
spatial_coverage <- dbGetQuery(con, "
WITH gps_bbox AS (
  SELECT ST_SetSRID(ST_Extent(geom), 4326) as bbox
  FROM temp_gps_sample
)
SELECT
  'Alcohol Venues' as category,
  COUNT(*) as poi_in_study_area
FROM public_data.osm_poi, gps_bbox
WHERE class = 'amenity'
  AND type IN ('bar', 'pub', 'nightclub', 'biergarten')
  AND ST_Intersects(geom, bbox)

UNION ALL

SELECT
  'Alcohol Retail' as category,
  COUNT(*) as poi_in_study_area
FROM public_data.osm_poi, gps_bbox
WHERE ((class = 'shop' AND type IN ('alcohol', 'wine'))
    OR (class = 'craft' AND type = 'brewery'))
  AND ST_Intersects(geom, bbox)

UNION ALL

SELECT
  'Recovery Facilities' as category,
  COUNT(*) as poi_in_study_area
FROM public_data.osm_poi, gps_bbox
WHERE ((class = 'amenity' AND type = 'social_facility')
    OR (class = 'healthcare' AND type IN ('clinic', 'centre')))
  AND ST_Intersects(geom, bbox);
")

spatial_coverage
```

```{r}
# Clean up temp sample table
dbExecute(con, "DROP TABLE IF EXISTS temp_gps_sample;")
```

**Interpretation:**
- Count = 0 → Category doesn't exist, skip enrichment
- Count < 10 → Sparse coverage, likely few matches
- Count > 100 → Good coverage, expect meaningful matches

## Load GPS Points into Temporary Database Table

For efficient spatial queries, we'll load GPS points into a temporary
database table with PostGIS geometries.

```{r}
# Select minimal columns needed for spatial joins
gps_spatial <- gps_data |>
  mutate(row_id = row_number()) |>
  select(row_id, lat, lon)
```

```{r}
# Write to temporary table
dbWriteTable(con, "temp_gps_points", gps_spatial, temporary = TRUE, overwrite = TRUE, row.names = FALSE)
```

This is basically the R equivalent of loading a dataset into the
environment. We want it to be available and ready for analyses quickly,
but not permanently.

```{r}
# Create geometry column
dbExecute(con, "
ALTER TABLE temp_gps_points
ADD COLUMN geom GEOMETRY(Point, 4326);
")

dbExecute(con, "
UPDATE temp_gps_points
SET geom = ST_SetSRID(ST_MakePoint(lon, lat), 4326);
")
```

`GEOMETRY(Point, 4326)` defines two major things:

1.  Point = Geometry Type

Specifies what kind of spatial object we are storing.

Options include:

-   Point (single location, like GPS coords)

-   LineString - A connected path (route)

-   Polygon - enclosed area (census block groups/landuse)

-   Multipoint, MultiPolygon, etc

2.  4326 = **SRID** (Spatial Reference System Identifier)

Specifies what coordinate system, and how to interpret the lat/lon
numbers.

This project uses **EPSG:4326 / WGS84**

They both refer to the same thing: 

-   WGS84 = "World Geodetic System 1984" 
-   EPSG:4326 = The code number for it from the EPSG registry

WGS84 is the coordinate system GPS satellites use:

-   Uses degrees (not meters/feet)

-   Covers the whole Earth

-   Good for storage and display

But notably **not suited for distance calculations**:

In Madison, Wisconsin's latitude (\~43°) - 1° lon = \~80km - 1° lat =
\~111km

At the equator: - 1° lon = \~ 111km - 1° lat = \~ 111km

The solution:

```{r}
# ST_MakePoint(lon, lat)  Creates a point 
# ST_SetSRID(..., 4326)   Tag it: "These are WGS84 lat/lon degrees"
```

Now PostGIS knows:

-   These are degrees, not meters

-   These points need to be converted to geography for accurate meter-based distances

-   Spatial indexes can be used to optimize this lat/lon data

Why Transform to Geometry Type?

-   PostGIS spatial indexes make "nearest neighbor" queries feasible.

-   Without spatial indexes, finding the nearest POI would require 1.24M GPS points × 85K POI = 105 billion distance calculations

Why can't we use those fancy spatial indexes on the lat/lons?

PostgreSQL's GIST indexes require a single column. The geometry type
packages both coordinates into one column, enabling spatial indexing.
You cannot create a GIST spatial index on `(lat, lon)` as separate
columns.

Use-case:

Queries will use both geometry and geography types: 

-   `geometry` when fast operations in degrees are necessary 

-   `geography` when accurate calculations in meters are necessary

```{r}
# Create spatial index for performance
dbExecute(con, "
CREATE INDEX idx_temp_gps_geom ON temp_gps_points USING GIST(geom);
")

# Create index on row_id for join performance
dbExecute(con, "
CREATE INDEX idx_temp_gps_row_id ON temp_gps_points(row_id);
")

# Update table statistics so query planner uses indexes
dbExecute(con, "ANALYZE temp_gps_points;")
```

```{r}
# Verify
dbGetQuery(con, "
SELECT COUNT(*) as total_points, COUNT(geom) as with_geometry
FROM temp_gps_points;
")
```

## Enrich with ADI Scores

Spatial join to match GPS points with census block group ADI scores.

```{r}
# Spatial join: point-in-polygon
#
# R-equivalent logic:
#   gps_data |>
#     left_join(adi_scores, by = st_within(gps_point, adi_polygon))
#
# SQL Explanation:
#   - LEFT JOIN: Keep all GPS points, even if no ADI match (R: left_join)
#   - ST_Within: Check if GPS point falls inside ADI polygon (R: st_within)

adi_results <- dbGetQuery(con, "
SELECT
    t.row_id,
    a.fips_2020,
    a.adi_national_percentile,
    a.adi_state_decile
FROM temp_gps_points t
LEFT JOIN public_data.adi_scores a
    ON ST_Within(t.geom, a.geometry)
ORDER BY t.row_id;
")

nrow(adi_results)
```

```{r}
# Check match rate
adi_results |>
  summarise(
    total_points = n(),
    with_adi = sum(!is.na(adi_national_percentile)),
    match_rate = round(sum(!is.na(adi_national_percentile)) / n() * 100, 2)
  )
```

## Enrich with Nearest High-Relevance POI

**Purpose:** Hierarchical POI matching for time-weighted individual-level lapse prediction.

**Approach:** For each GPS point, find the single nearest POI across all high-relevance
categories (alcohol venues, alcohol retail, recovery facilities). This captures
**primary exposure** - whichever risk/protective factor is closest.

**Why hierarchical matching?**
- **Simplicity:** 1 query instead of 3, faster execution
- **Primary exposure:** Most GPS points near only one POI type
- **Higher match rate:** ~15-20% vs 10% per category
- **Still allows differential analysis:** Can aggregate by POI category type

**Categories included (HIGH tier evidence):**
- **Alcohol venues** (bars, pubs, nightclubs) - risky exposure
- **Alcohol retail** (liquor stores, wine shops) - risky exposure
- **Recovery facilities** (treatment centers, sober living) - protective exposure

**Distance threshold:** 100 meters captures both:
- Direct visits (20-50m): Person is AT the POI
- Immediate exposure (50-100m): POI in walkable environment

**Source:** Evidence synthesis from addiction research, environmental epidemiology,
and CDC alcohol outlet measurement standards. See research_POI.md for full citations.

### How the Query Works

**R-Equivalent Logic:**

``` r
# For each GPS point, find nearest POI of ANY high-relevance type within 100m
gps_data |>
  group_by(row_id) |>
  mutate(
    nearest_poi_result = find_closest_poi(this_point, all_high_risk_poi, max_dist = 100)
  ) |>
  filter(distance <= 100) |>
  slice_head(n = 1)
```

**SQL Pattern:**

- `CROSS JOIN LATERAL`: For each GPS point, search POI table
- `WHERE (category1) OR (category2) OR (category3)`: Consider all high-relevance types
- `ORDER BY poi.geom <-> gps.geom`: Use spatial index for fast nearest-neighbor
- `LIMIT 5`: Get 5 closest candidates for accurate geography filtering
- `ST_DWithin(..., 100)`: Pre-filter to 100m radius
- `DISTINCT ON (gps.row_id)`: Return only nearest match per GPS point
- `CASE`: Categorize result into alcohol_venue, alcohol_retail, or recovery_facility

### Execute Hierarchical POI Query

```{r}
# Single query for nearest high-relevance POI across all categories
nearest_poi <- dbGetQuery(con, "
SELECT DISTINCT ON (gps.row_id)
    gps.row_id,
    poi.class,
    poi.type,
    CASE
        WHEN poi.class = 'amenity' AND poi.type IN ('bar', 'pub', 'nightclub', 'biergarten')
            THEN 'alcohol_venue'
        WHEN (poi.class = 'shop' AND poi.type IN ('alcohol', 'wine'))
            OR (poi.class = 'craft' AND poi.type = 'brewery')
            THEN 'alcohol_retail'
        WHEN (poi.class = 'amenity' AND poi.type = 'social_facility')
            OR (poi.class = 'healthcare' AND poi.type IN ('clinic', 'centre'))
            THEN 'recovery_facility'
    END as poi_category,
    ROUND(ST_Distance(gps.geom::geography, poi.geom::geography)::numeric, 2) as distance_m
FROM temp_gps_points gps
CROSS JOIN LATERAL (
    SELECT class, type, geom
    FROM public_data.osm_poi poi
    WHERE
        -- Alcohol venues (on-premise)
        (poi.class = 'amenity' AND poi.type IN ('bar', 'pub', 'nightclub', 'biergarten'))
        -- Alcohol retail (off-premise)
        OR ((poi.class = 'shop' AND poi.type IN ('alcohol', 'wine'))
            OR (poi.class = 'craft' AND poi.type = 'brewery'))
        -- Recovery facilities
        OR ((poi.class = 'amenity' AND poi.type = 'social_facility')
            OR (poi.class = 'healthcare' AND poi.type IN ('clinic', 'centre')))
    ORDER BY poi.geom <-> gps.geom
    LIMIT 5
) poi
WHERE ST_DWithin(poi.geom::geography, gps.geom::geography, 100)
ORDER BY gps.row_id, poi.geom <-> gps.geom;
")

nrow(nearest_poi)
```

```{r}
# Check overall match rate
tibble(
  total_points = nrow(gps_data),
  with_poi = nrow(nearest_poi),
  match_rate_pct = round(nrow(nearest_poi) / nrow(gps_data) * 100, 2)
)
```

## Join All Enrichments

```{r}
# Start with original GPS data and add row_id
gps_enriched <- gps_data |>
  mutate(row_id = row_number())

# Join ADI data
gps_enriched <- gps_enriched |>
  left_join(adi_results, by = "row_id")

# Join nearest POI data (single hierarchical result)
gps_enriched <- gps_enriched |>
  left_join(nearest_poi, by = "row_id")

# Remove temporary row_id
gps_enriched <- gps_enriched |>
  select(-row_id)

nrow(gps_enriched)
```

## Summary Statistics

### ADI Coverage

```{r}
gps_enriched |>
  summarise(
    total_points = n(),
    with_adi = sum(!is.na(adi_national_percentile)),
    match_rate_pct = round(sum(!is.na(adi_national_percentile)) / n() * 100, 2)
  ) |>
  knitr::kable()
```

### POI Coverage by Category

```{r}
gps_enriched |>
  filter(!is.na(poi_category)) |>
  count(poi_category) |>
  mutate(
    match_rate_pct = round(n / nrow(gps_enriched) * 100, 2),
    category_label = case_when(
      poi_category == "alcohol_venue" ~ "Alcohol Venues (on-premise)",
      poi_category == "alcohol_retail" ~ "Alcohol Retail (off-premise)",
      poi_category == "recovery_facility" ~ "Recovery Facilities"
    ),
    type = case_when(
      poi_category %in% c("alcohol_venue", "alcohol_retail") ~ "Risky",
      poi_category == "recovery_facility" ~ "Protective"
    )
  ) |>
  select(category_label, type, matches = n, match_rate_pct) |>
  knitr::kable()
```

### POI Type Distribution

**All POI by Specific Type:**

```{r}
gps_enriched |>
  filter(!is.na(poi_category)) |>
  count(poi_category, type, sort = TRUE) |>
  knitr::kable()
```

**Summary by Category:**

```{r}
gps_enriched |>
  filter(!is.na(poi_category)) |>
  group_by(poi_category) |>
  summarise(
    total_matches = n(),
    mean_distance_m = round(mean(distance_m, na.rm = TRUE), 1),
    median_distance_m = round(median(distance_m, na.rm = TRUE), 1),
    min_distance_m = round(min(distance_m, na.rm = TRUE), 1),
    max_distance_m = round(max(distance_m, na.rm = TRUE), 1)
  ) |>
  knitr::kable()
```

## Downstream Analysis: Time-Weighted Aggregation

**Purpose:** These point-level POI matches will be aggregated to create
subject-level features for lapse prediction modeling.

**Example aggregation strategies:**

```{r eval=FALSE}
# Example 1: Proportion of time near each POI category
subject_features <- gps_enriched |>
  group_by(subid) |>
  summarize(
    # % of GPS points within 50m of alcohol venues
    pct_time_near_alcohol_venue = mean(poi_category == "alcohol_venue" & distance_m <= 50, na.rm = TRUE),

    # % of GPS points within 100m of alcohol retail
    pct_time_near_alcohol_retail = mean(poi_category == "alcohol_retail" & distance_m <= 100, na.rm = TRUE),

    # % of GPS points within 100m of recovery facilities
    pct_time_near_recovery = mean(poi_category == "recovery_facility" & distance_m <= 100, na.rm = TRUE)
  )

# Example 2: Average proximity by category
subject_features <- gps_enriched |>
  group_by(subid, poi_category) |>
  summarize(mean_distance = mean(distance_m, na.rm = TRUE), .groups = "drop") |>
  pivot_wider(names_from = poi_category, values_from = mean_distance,
              names_prefix = "mean_dist_")

# Example 3: Visit counts by category
subject_features <- gps_enriched |>
  group_by(subid) |>
  summarize(
    # Number of GPS points within 50m of alcohol venues (direct visits)
    n_alcohol_venue_visits = sum(poi_category == "alcohol_venue" & distance_m <= 50, na.rm = TRUE),

    # Number of GPS points within 50m of alcohol retail
    n_alcohol_retail_visits = sum(poi_category == "alcohol_retail" & distance_m <= 50, na.rm = TRUE),

    # Number of GPS points within 100m of recovery facilities
    n_recovery_visits = sum(poi_category == "recovery_facility" & distance_m <= 100, na.rm = TRUE)
  )

# Example 4: Combined exposure metrics
subject_features <- gps_enriched |>
  group_by(subid) |>
  summarize(
    # Any alcohol exposure (venue OR retail)
    pct_time_near_any_alcohol = mean(poi_category %in% c("alcohol_venue", "alcohol_retail") & distance_m <= 100, na.rm = TRUE),

    # Alcohol vs recovery ratio
    alcohol_points = sum(poi_category %in% c("alcohol_venue", "alcohol_retail"), na.rm = TRUE),
    recovery_points = sum(poi_category == "recovery_facility", na.rm = TRUE),
    alcohol_recovery_ratio = if_else(recovery_points > 0, alcohol_points / recovery_points, NA_real_)
  )
```

**Sample size check:**

With N=167 subjects and 3 aggregated features:
- 167 ÷ 3 = **56 observations per feature**
- Well above minimum threshold of 10-20 obs/feature
- Can support additional interaction terms or covariates if needed

## Write Enriched Data

```{r}
# Output path
output_path <- str_c(path_shared, "/gps_enriched_all.csv")

# Write enriched data
write_csv(gps_enriched, output_path)
```

```{r}
# Verify file was written
file.info(output_path)$size / 1024^2  # Size in MB
```

## Cleanup

```{r}
# Drop temporary table
dbExecute(con, "DROP TABLE IF EXISTS temp_gps_points;")

# Disconnect
disconnect_db(con)
```
