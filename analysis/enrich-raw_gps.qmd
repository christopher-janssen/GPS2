---
title: "Enrich GPS Data with Spatial Context"
author: "Christopher Janssen"
date: "`r lubridate::today()`"
format:
  html:
    self-contained: true
editor_options:
  chunk_output_type: console
editor:
  markdown:
    wrap: 72
---

# GPS Data Enrichment

This notebook enriches GPS data with spatial context from the database:

-   **ADI scores**: Census block group deprivation index

-   **Nearest POI**: Hierarchical matching for environmental context and
    lapse prediction

    **Tier 1 - Strongest Evidence (Alcohol/Recovery):**

    -   Alcohol venues (on-premise): bars, pubs, nightclubs
    -   Alcohol retail (off-premise): liquor stores, alcohol shops
    -   Recovery facilities: treatment centers, sober living

    **Tier 2 - Moderate Evidence (Environmental Context):**

    -   Restaurants/food: social eating contexts, alcohol availability
    -   Parks/green spaces: protective factor, healthy coping
        environments
    -   Healthcare facilities: treatment engagement, routine care
    -   Grocery/convenience stores: routine activities, alcohol access
        points

**POI Matching:** Hierarchical - finds single nearest POI across all
categories within 100m

**Distance Limit:** 100 meters (captures direct visits + immediate
nearby exposure)

## Setup

```{r include=FALSE}
source(here::here("scripts/r/setup.R"))
source(here::here("scripts/r/connection.R"))

# Connect to database
con <- connect_to_db()
```

## Load GPS Data

```{r}
# Filepath
gps_path <- str_c(path_shared, "/gps_enriched.csv")

# read data
gps_data <- read_csv(gps_path, show_col_types = FALSE)

nrow(gps_data)
```

```{r}
glimpse(gps_data)
```

## POI Availability Check

**Purpose:** Verify that POI categories exist in our study area before
running expensive spatial queries. Check both database-wide availability
and spatial overlap with GPS coverage area.

### POI Counts by Target Category

```{r}
# Count POI by our target categories (Tier 1 + Tier 2)
poi_availability <- dbGetQuery(con, "
SELECT
  CASE
    -- TIER 1: Alcohol/Recovery (strongest evidence)
    WHEN class = 'amenity' AND type IN ('bar', 'pub', 'nightclub', 'biergarten')
      THEN 'alcohol_venue'
    WHEN (class = 'shop' AND type IN ('alcohol', 'wine'))
      OR (class = 'craft' AND type = 'brewery')
      THEN 'alcohol_retail'
    WHEN (class = 'amenity' AND type = 'social_facility')
      OR (class = 'healthcare' AND type IN ('clinic', 'centre'))
      THEN 'recovery_facility'
    -- TIER 2: Environmental context (moderate evidence)
    WHEN class = 'amenity' AND type IN ('restaurant', 'cafe', 'fast_food', 'food_court')
      THEN 'restaurant'
    WHEN class = 'leisure' AND type IN ('park', 'nature_reserve', 'garden', 'recreation_ground')
      THEN 'park'
    WHEN class = 'amenity' AND type IN ('hospital', 'clinic', 'doctors', 'pharmacy')
      THEN 'healthcare'
    WHEN class = 'shop' AND type IN ('convenience', 'supermarket', 'general', 'grocery')
      THEN 'grocery'
    ELSE 'other'
  END as poi_category,
  COUNT(*) as n_poi
FROM public_data.osm_poi
GROUP BY poi_category
ORDER BY n_poi DESC;
")

poi_availability
```

### Detailed Breakdown by Type

**TIER 1: Alcohol/Recovery**

**Alcohol Venues:**

```{r}
dbGetQuery(con, "
SELECT type, COUNT(*) as count
FROM public_data.osm_poi
WHERE class = 'amenity'
  AND type IN ('bar', 'pub', 'nightclub', 'biergarten')
GROUP BY type
ORDER BY count DESC;
")
```

**Alcohol Retail:**

```{r}
dbGetQuery(con, "
SELECT class, type, COUNT(*) as count
FROM public_data.osm_poi
WHERE (class = 'shop' AND type IN ('alcohol', 'wine'))
   OR (class = 'craft' AND type = 'brewery')
GROUP BY class, type
ORDER BY count DESC;
")
```

**Recovery Facilities:**

```{r}
dbGetQuery(con, "
SELECT class, type, COUNT(*) as count
FROM public_data.osm_poi
WHERE (class = 'amenity' AND type = 'social_facility')
   OR (class = 'healthcare' AND type IN ('clinic', 'centre'))
GROUP BY class, type
ORDER BY count DESC;
")
```

**TIER 2: Environmental Context**

**Restaurants/Food:**

```{r}
dbGetQuery(con, "
SELECT type, COUNT(*) as count
FROM public_data.osm_poi
WHERE class = 'amenity'
  AND type IN ('restaurant', 'cafe', 'fast_food', 'food_court')
GROUP BY type
ORDER BY count DESC;
")
```

**Parks/Green Spaces:**

```{r}
dbGetQuery(con, "
SELECT type, COUNT(*) as count
FROM public_data.osm_poi
WHERE class = 'leisure'
  AND type IN ('park', 'nature_reserve', 'garden', 'recreation_ground')
GROUP BY type
ORDER BY count DESC;
")
```

**Healthcare Facilities:**

```{r}
dbGetQuery(con, "
SELECT type, COUNT(*) as count
FROM public_data.osm_poi
WHERE class = 'amenity'
  AND type IN ('hospital', 'clinic', 'doctors', 'pharmacy')
GROUP BY type
ORDER BY count DESC;
")
```

**Grocery/Convenience Stores:**

```{r}
dbGetQuery(con, "
SELECT type, COUNT(*) as count
FROM public_data.osm_poi
WHERE class = 'shop'
  AND type IN ('convenience', 'supermarket', 'general', 'grocery')
GROUP BY type
ORDER BY count DESC;
")
```

### Spatial Coverage Check

Check if POI are distributed within our GPS coverage area (bounding
box).

```{r}
# Sample GPS points to create bounding box (use 10k points for speed)
gps_distinct <- gps_data |>
  distinct(lat, lon)

gps_sample <- gps_distinct |>
  slice_sample(n = min(10000, nrow(gps_distinct)))

# Write sample to temp table
dbWriteTable(con, "temp_gps_sample", gps_sample, temporary = TRUE, overwrite = TRUE, row.names = FALSE)

# Create geometries
dbExecute(con, "
ALTER TABLE temp_gps_sample
ADD COLUMN geom GEOMETRY(Point, 4326);
")

dbExecute(con, "
UPDATE temp_gps_sample
SET geom = ST_SetSRID(ST_MakePoint(lon, lat), 4326);
")
```

```{r}
# Count POI within GPS bounding box (all tiers)
spatial_coverage <- dbGetQuery(con, "
WITH gps_bbox AS (
  SELECT ST_SetSRID(ST_Extent(geom), 4326) as bbox
  FROM temp_gps_sample
)
-- TIER 1: Alcohol/Recovery
SELECT
  'Alcohol Venues' as category,
  'Tier 1' as tier,
  COUNT(*) as poi_in_study_area
FROM public_data.osm_poi, gps_bbox
WHERE class = 'amenity'
  AND type IN ('bar', 'pub', 'nightclub', 'biergarten')
  AND ST_Intersects(geom, bbox)

UNION ALL

SELECT
  'Alcohol Retail' as category,
  'Tier 1' as tier,
  COUNT(*) as poi_in_study_area
FROM public_data.osm_poi, gps_bbox
WHERE ((class = 'shop' AND type IN ('alcohol', 'wine'))
    OR (class = 'craft' AND type = 'brewery'))
  AND ST_Intersects(geom, bbox)

UNION ALL

SELECT
  'Recovery Facilities' as category,
  'Tier 1' as tier,
  COUNT(*) as poi_in_study_area
FROM public_data.osm_poi, gps_bbox
WHERE ((class = 'amenity' AND type = 'social_facility')
    OR (class = 'healthcare' AND type IN ('clinic', 'centre')))
  AND ST_Intersects(geom, bbox)

-- TIER 2: Environmental Context
UNION ALL

SELECT
  'Restaurants/Food' as category,
  'Tier 2' as tier,
  COUNT(*) as poi_in_study_area
FROM public_data.osm_poi, gps_bbox
WHERE class = 'amenity'
  AND type IN ('restaurant', 'cafe', 'fast_food', 'food_court')
  AND ST_Intersects(geom, bbox)

UNION ALL

SELECT
  'Parks/Green Spaces' as category,
  'Tier 2' as tier,
  COUNT(*) as poi_in_study_area
FROM public_data.osm_poi, gps_bbox
WHERE class = 'leisure'
  AND type IN ('park', 'nature_reserve', 'garden', 'recreation_ground')
  AND ST_Intersects(geom, bbox)

UNION ALL

SELECT
  'Healthcare Facilities' as category,
  'Tier 2' as tier,
  COUNT(*) as poi_in_study_area
FROM public_data.osm_poi, gps_bbox
WHERE class = 'amenity'
  AND type IN ('hospital', 'clinic', 'doctors', 'pharmacy')
  AND ST_Intersects(geom, bbox)

UNION ALL

SELECT
  'Grocery/Convenience' as category,
  'Tier 2' as tier,
  COUNT(*) as poi_in_study_area
FROM public_data.osm_poi, gps_bbox
WHERE class = 'shop'
  AND type IN ('convenience', 'supermarket', 'general', 'grocery')
  AND ST_Intersects(geom, bbox)

ORDER BY tier, poi_in_study_area DESC;
")

spatial_coverage
```

```{r}
# Clean up temp sample table
dbExecute(con, "DROP TABLE IF EXISTS temp_gps_sample;")
```

## Load GPS Points into Temporary Database Table

For efficient spatial queries, we'll load GPS points into a temporary
database table with PostGIS geometries.

```{r}
# Select minimal columns needed for spatial joins
gps_spatial <- gps_data |>
  mutate(row_id = row_number()) |>
  select(row_id, lat, lon)
```

```{r}
# Write to temporary table
dbWriteTable(con, "temp_gps_points", gps_spatial, temporary = TRUE, overwrite = TRUE, row.names = FALSE)
```

This is basically the R equivalent of loading a dataset into the
environment. We want it to be available and ready for analyses quickly,
but not permanently.

```{r}
# Create geometry column
dbExecute(con, "
ALTER TABLE temp_gps_points
ADD COLUMN geom GEOMETRY(Point, 4326);
")

dbExecute(con, "
UPDATE temp_gps_points
SET geom = ST_SetSRID(ST_MakePoint(lon, lat), 4326);
")
```

`GEOMETRY(Point, 4326)` defines two major things:

1.  Point = Geometry Type

Specifies what kind of spatial object we are storing.

Options include:

-   Point (single location, like GPS coords)

-   LineString - A connected path (route)

-   Polygon - enclosed area (census block groups/landuse)

-   Multipoint, MultiPolygon, etc

2.  4326 = **SRID** (Spatial Reference System Identifier)

Specifies what coordinate system, and how to interpret the lat/lon
numbers.

This project uses **EPSG:4326 / WGS84**

They both refer to the same thing:

-   WGS84 = "World Geodetic System 1984"
-   EPSG:4326 = The code number for it from the EPSG registry

WGS84 is the coordinate system GPS satellites use:

-   Uses degrees (not meters/feet)

-   Covers the whole Earth

-   Good for storage and display

But notably **not suited for distance calculations**:

In Madison, Wisconsin's latitude (\~43°) - 1° lon = \~80km - 1° lat =
\~111km

At the equator: - 1° lon = \~ 111km - 1° lat = \~ 111km

The solution:

```{r}
# ST_MakePoint(lon, lat)  Creates a point 
# ST_SetSRID(..., 4326)   Tag it: "These are WGS84 lat/lon degrees"
```

Now PostGIS knows:

-   These are degrees, not meters

-   These points need to be converted to geography for accurate
    meter-based distances

-   Spatial indexes can be used to optimize this lat/lon data

Why Transform to Geometry Type?

-   PostGIS spatial indexes make "nearest neighbor" queries feasible.

-   Without spatial indexes, finding the nearest POI would require 1.24M
    GPS points × 85K POI = 105 billion distance calculations

Why can't we use those fancy spatial indexes on the lat/lons?

PostgreSQL's GIST indexes require a single column. The geometry type
packages both coordinates into one column, enabling spatial indexing.
You cannot create a GIST spatial index on `(lat, lon)` as separate
columns.

Use-case:

Queries will use both geometry and geography types:

-   `geometry` when fast operations in degrees are necessary

-   `geography` when accurate calculations in meters are necessary

```{r}
# Create spatial index for performance
dbExecute(con, "
CREATE INDEX idx_temp_gps_geom ON temp_gps_points USING GIST(geom);
")

# Create index on row_id for join performance
dbExecute(con, "
CREATE INDEX idx_temp_gps_row_id ON temp_gps_points(row_id);
")

# Update table statistics so query planner uses indexes
dbExecute(con, "ANALYZE temp_gps_points;")
```

```{r}
# Verify
dbGetQuery(con, "
SELECT COUNT(*) as total_points, COUNT(geom) as with_geometry
FROM temp_gps_points;
")
```

## Enrich with ADI Scores

Spatial join to match GPS points with census block group ADI scores.

```{r}
# Spatial join: point-in-polygon
#
# R-equivalent logic:
#   gps_data |>
#     left_join(adi_scores, by = st_within(gps_point, adi_polygon))
#
# SQL Explanation:
#   - LEFT JOIN: Keep all GPS points, even if no ADI match (R: left_join)
#   - ST_Within: Check if GPS point falls inside ADI polygon (R: st_within)

adi_results <- dbGetQuery(con, "
SELECT
    t.row_id,
    a.fips_2020,
    a.adi_national_percentile,
    a.adi_state_decile
FROM temp_gps_points t
LEFT JOIN public_data.adi_scores a
    ON ST_Within(t.geom, a.geometry)
ORDER BY t.row_id;
")

nrow(adi_results)
```

```{r}
# Check match rate
adi_results |>
  summarise(
    total_points = n(),
    with_adi = sum(!is.na(adi_national_percentile)),
    match_rate = round(sum(!is.na(adi_national_percentile)) / n() * 100, 2)
  )
```

## Enrich with Nearest POI (All Tiers)

**Purpose:** Hierarchical POI matching for environmental
contextualization and lapse prediction.

**Approach:** For each GPS point, find the single nearest POI across all
categories (Tier 1 alcohol/recovery + Tier 2 environmental context).
This captures **primary exposure**, whichever environmental factor is
closest.

**Why hierarchical matching?**

-   **Simplicity:** 1 query instead of 7, much faster execution

-   **Primary exposure:** Most GPS points near only one POI type

-   **Higher match rate:** \~20-30% vs 5-10% per category

-   **Still allows differential analysis:** Can aggregate by POI
    category type

-   **Feature reduction flexibility:** Include/exclude categories during
    modeling phase

**Categories included:**

**Tier 1 - Strongest Evidence (Alcohol/Recovery):**

-   **Alcohol venues** (bars, pubs, nightclubs) - risky exposure

-   **Alcohol retail** (liquor stores, wine shops) - risky exposure

-   **Recovery facilities** (treatment centers, sober living) -
    protective exposure

**Tier 2 - Moderate Evidence (Environmental Context):**

-   **Restaurants/food** (restaurants, cafes, fast food) - social
    context, alcohol availability

-   **Parks/green spaces** (parks, nature reserves) - protective,
    healthy coping

-   **Healthcare facilities** (hospitals, clinics, pharmacies) -
    treatment engagement

-   **Grocery/convenience** (supermarkets, convenience stores) - routine
    activities, alcohol access

**Distance threshold:** 100 meters captures both:

-   Direct visits (20-50m): Person is AT the POI

-   Immediate exposure (50-100m): POI in walkable environment

### How the Query Works

**R-Equivalent Logic:**

``` r
# For each GPS point, find nearest POI of ANY type (all 7 categories) within 100m
gps_data |>
  group_by(row_id) |>
  mutate(
    nearest_poi_result = find_closest_poi(this_point, all_poi_categories, max_dist = 100)
  ) |>
  filter(distance <= 100) |>
  slice_head(n = 1)
```

**SQL Pattern:**

-   `CROSS JOIN LATERAL`: For each GPS point, search POI table
-   `WHERE (tier1_cats) OR (tier2_cats)`: Consider all 7 POI types
-   `ORDER BY poi.geom <-> gps.geom`: Use spatial index for fast
    nearest-neighbor
-   `LIMIT 5`: Get 5 closest candidates for accurate geography filtering
-   `ST_DWithin(..., 100)`: Pre-filter to 100m radius
-   `DISTINCT ON (gps.row_id)`: Return only nearest match per GPS point
-   `CASE`: Categorize into 7 types (3 Tier 1, 4 Tier 2)

### Execute Hierarchical POI Query (All Tiers)

```{r}
# Single query for nearest POI across all categories (Tier 1 + Tier 2)
nearest_poi <- dbGetQuery(con, "
SELECT DISTINCT ON (gps.row_id)
    gps.row_id,
    poi.class,
    poi.type,
    CASE
        -- TIER 1: Alcohol/Recovery (strongest evidence)
        WHEN poi.class = 'amenity' AND poi.type IN ('bar', 'pub', 'nightclub', 'biergarten')
            THEN 'alcohol_venue'
        WHEN (poi.class = 'shop' AND poi.type IN ('alcohol', 'wine'))
            OR (poi.class = 'craft' AND poi.type = 'brewery')
            THEN 'alcohol_retail'
        WHEN (poi.class = 'amenity' AND poi.type = 'social_facility')
            OR (poi.class = 'healthcare' AND poi.type IN ('clinic', 'centre'))
            THEN 'recovery_facility'
        -- TIER 2: Environmental context (moderate evidence)
        WHEN poi.class = 'amenity' AND poi.type IN ('restaurant', 'cafe', 'fast_food', 'food_court')
            THEN 'restaurant'
        WHEN poi.class = 'leisure' AND poi.type IN ('park', 'nature_reserve', 'garden', 'recreation_ground')
            THEN 'park'
        WHEN poi.class = 'amenity' AND poi.type IN ('hospital', 'clinic', 'doctors', 'pharmacy')
            THEN 'healthcare'
        WHEN poi.class = 'shop' AND poi.type IN ('convenience', 'supermarket', 'general', 'grocery')
            THEN 'grocery'
    END as poi_category,
    ROUND(ST_Distance(gps.geom::geography, poi.geom::geography)::numeric, 2) as distance_m
FROM temp_gps_points gps
CROSS JOIN LATERAL (
    SELECT class, type, geom
    FROM public_data.osm_poi poi
    WHERE
        -- TIER 1: Alcohol venues (on-premise)
        (poi.class = 'amenity' AND poi.type IN ('bar', 'pub', 'nightclub', 'biergarten'))
        -- TIER 1: Alcohol retail (off-premise)
        OR ((poi.class = 'shop' AND poi.type IN ('alcohol', 'wine'))
            OR (poi.class = 'craft' AND poi.type = 'brewery'))
        -- TIER 1: Recovery facilities
        OR ((poi.class = 'amenity' AND poi.type = 'social_facility')
            OR (poi.class = 'healthcare' AND poi.type IN ('clinic', 'centre')))
        -- TIER 2: Restaurants/food
        OR (poi.class = 'amenity' AND poi.type IN ('restaurant', 'cafe', 'fast_food', 'food_court'))
        -- TIER 2: Parks/green spaces
        OR (poi.class = 'leisure' AND poi.type IN ('park', 'nature_reserve', 'garden', 'recreation_ground'))
        -- TIER 2: Healthcare facilities (broader than recovery-specific)
        OR (poi.class = 'amenity' AND poi.type IN ('hospital', 'clinic', 'doctors', 'pharmacy'))
        -- TIER 2: Grocery/convenience stores
        OR (poi.class = 'shop' AND poi.type IN ('convenience', 'supermarket', 'general', 'grocery'))
    ORDER BY poi.geom <-> gps.geom
    LIMIT 5
) poi
WHERE ST_DWithin(poi.geom::geography, gps.geom::geography, 100)
ORDER BY gps.row_id, poi.geom <-> gps.geom;
")

nrow(nearest_poi)
```

```{r}
# Check overall match rate
tibble(
  total_points = nrow(gps_data),
  with_poi = nrow(nearest_poi),
  match_rate_pct = round(nrow(nearest_poi) / nrow(gps_data) * 100, 2)
)
```

## Join All Enrichments

```{r}
# Start with original GPS data and add row_id
gps_enriched <- gps_data |>
  mutate(row_id = row_number())

# Join ADI data
gps_enriched <- gps_enriched |>
  left_join(adi_results, by = "row_id")

# Join nearest POI data (single hierarchical result)
gps_enriched <- gps_enriched |>
  left_join(nearest_poi, by = "row_id")

# Remove temporary row_id and fix POI column names
gps_enriched <- gps_enriched |>
  select(-row_id, -type.x) |>
  rename(type = type.y)

nrow(gps_enriched)
```

## Summary Statistics

### ADI Coverage

```{r}
gps_enriched |>
  summarise(
    total_points = n(),
    with_adi = sum(!is.na(adi_national_percentile)),
    match_rate_pct = round(sum(!is.na(adi_national_percentile)) / n() * 100, 2)
  ) |>
  knitr::kable()
```

### POI Coverage by Category

```{r}
gps_enriched |>
  filter(!is.na(poi_category)) |>
  count(poi_category) |>
  mutate(
    match_rate_pct = round(n / nrow(gps_enriched) * 100, 2),
    tier = case_when(
      poi_category %in% c("alcohol_venue", "alcohol_retail", "recovery_facility") ~ "Tier 1",
      poi_category %in% c("restaurant", "park", "healthcare", "grocery") ~ "Tier 2"
    ),
    category_label = case_when(
      poi_category == "alcohol_venue" ~ "Alcohol Venues",
      poi_category == "alcohol_retail" ~ "Alcohol Retail",
      poi_category == "recovery_facility" ~ "Recovery Facilities",
      poi_category == "restaurant" ~ "Restaurants/Food",
      poi_category == "park" ~ "Parks/Green Spaces",
      poi_category == "healthcare" ~ "Healthcare Facilities",
      poi_category == "grocery" ~ "Grocery/Convenience"
    ),
    exposure_type = case_when(
      poi_category %in% c("alcohol_venue", "alcohol_retail") ~ "Risky",
      poi_category %in% c("recovery_facility", "park", "healthcare") ~ "Protective",
      poi_category %in% c("restaurant", "grocery") ~ "Mixed/Context"
    )
  ) |>
  arrange(tier, desc(n)) |>
  select(tier, category_label, exposure_type, matches = n, match_rate_pct) |>
  knitr::kable()
```

### POI Type Distribution

**All POI by Specific Type:**

```{r}
gps_enriched |>
  filter(!is.na(poi_category)) |>
  count(poi_category, sort = TRUE) |>
  knitr::kable()
```

**Summary by Category:**

```{r}
gps_enriched |>
  filter(!is.na(poi_category)) |>
  group_by(poi_category) |>
  summarise(
    total_matches = n(),
    mean_distance_m = round(mean(distance_m, na.rm = TRUE), 1),
    median_distance_m = round(median(distance_m, na.rm = TRUE), 1),
    min_distance_m = round(min(distance_m, na.rm = TRUE), 1),
    max_distance_m = round(max(distance_m, na.rm = TRUE), 1)
  ) |>
  knitr::kable()
```

## Write Enriched Data

```{r}
# Output path
output_path <- str_c(path_shared, "/gps_enriched_all.csv")

# Write enriched data
write_csv(gps_enriched, output_path)
```

```{r}
# Verify file was written
file.info(output_path)$size / 1024^2  # Size in MB
```

## Cleanup

```{r}
# Drop temporary table
dbExecute(con, "DROP TABLE IF EXISTS temp_gps_points;")

# Disconnect
disconnect_db(con)
```
