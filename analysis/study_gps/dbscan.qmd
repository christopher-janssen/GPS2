---
title: "DBSCAN Parameter Grid Search"
author: "Christopher Janssen"
date: "`r lubridate::today()`"
format:
  html:
    self-contained: true
editor_options:
  chunk_output_type: console
editor:
  markdown:
    wrap: 72
---

# Parameter Grid Search

Grid search over dwell threshold × eps × minPts (4 × 4 × 4 = 64
combinations). Stay detection depends only on dwell threshold;
DBSCAN clustering uses eps and minPts. Evaluation is against three
ground truth sets: all reported locations, intake-only, and
non-intake.

## Setup

```{r}
#| include: false

source(here::here("scripts/r/setup.R"))

library(geosphere)
library(leaflet)
library(furrr)
library(clue)

plan(multisession, workers = availableCores() - 1)

theme_set(theme_minimal())
```

## Parameters

```{r}
# Dwell time thresholds to test
DWELL_THRESHOLDS <- c(2, 5, 10, 15)

# DBSCAN clustering parameters (grid search)
EPS_VALUES <- c(25, 50, 75, 100)
MINPTS_VALUES <- c(2, 3, 4, 5)

param_grid <- expand_grid(
  dwell_threshold = DWELL_THRESHOLDS,
  eps_meters = EPS_VALUES,
  min_pts = MINPTS_VALUES
)
nrow(param_grid)

# Ground truth and matching
PROXIMITY_THRESHOLD <- 100
DEDUPE_THRESHOLD <- 50

# Stay detection parameters
DIST_THRESHOLD <- 50
MAX_GAP <- 60
MAX_STAY_HOURS <- 12
```

## Load & Filter Data

```{r}
study_dates <- read_csv(
  here::here(path_shared, "study_dates_gps.csv"),
  show_col_types = FALSE
) |>
  mutate(
    study_start = as_date(study_start),
    study_end = as_date(study_end)
  )

subids_dates <- study_dates |>
  pull(subid) |>
  unique()
```

```{r}
gps_data <- read_csv(
  here::here(path_gps2, "data/processed_gps.csv"),
  show_col_types = FALSE
) |>
  filter(subid %in% subids_dates)

nrow(gps_data)
```

```{r}
locs_gt <- read_csv(
  here::here(path_gps2, "data/locs_gt.csv"),
  show_col_types = FALSE
) |>
  mutate(subid = as.numeric(subid)) |>
  filter(subid %in% subids_dates)

nrow(locs_gt)
```

## Helper Functions

### Stay Detection

Encapsulates the stay detection pipeline from
`detect-stay-points.qmd`: calculate movement metrics, identify stay
boundaries, aggregate to stay-level, filter by dwell time.

```{r}
detect_stays <- function(gps_data, dist_threshold = DIST_THRESHOLD,
                         time_threshold = 10, max_gap = MAX_GAP,
                         max_hours = MAX_STAY_HOURS) {
  # Movement metrics
  data <- gps_data |>
    group_by(subid) |>
    mutate(
      dist_from_prev = if_else(
        row_number() == 1,
        NA_real_,
        distHaversine(cbind(lag(lon), lag(lat)), cbind(lon, lat))
      ),
      time_gap_mins = if_else(
        row_number() == 1,
        NA_real_,
        as.numeric(difftime(time_local, lag(time_local), units = "mins"))
      )
    ) |>
    ungroup()

  # Stay boundaries
  data <- data |>
    group_by(subid) |>
    mutate(
      is_new_stay = row_number() == 1 |
        dist_from_prev > dist_threshold |
        time_gap_mins > max_gap,
      stay_id_subject = cumsum(is_new_stay)
    ) |>
    ungroup()

  # Aggregate to stay-level
  stays_raw <- data |>
    group_by(subid, stay_id_subject) |>
    summarize(
      start_time = min(time_local),
      end_time = max(time_local),
      dwell_mins = as.numeric(difftime(max(time_local),
                                       min(time_local), units = "mins")),
      n_points = n(),
      lat = median(lat),
      lon = median(lon),
      .groups = "drop"
    )

  # Filter by dwell time
  stays_raw |>
    filter(dwell_mins >= time_threshold & dwell_mins <= max_hours * 60) |>
    mutate(stay_id = row_number()) |>
    select(stay_id, subid, start_time, end_time, dwell_mins, n_points,
           lat, lon)
}
```

### DBSCAN Clustering

```{r}
run_dbscan <- function(coords, eps = 50, min_pts = 3) {
  if (nrow(coords) < 2) {
    return(list(
      cluster = rep(1, nrow(coords)),
      n_clusters = 1,
      n_noise = 0
    ))
  }

  dist_mat <- distm(coords, coords, fun = distHaversine)
  result <- dbscan(as.dist(dist_mat), eps = eps, minPts = min_pts)

  list(
    cluster = result$cluster,
    n_clusters = max(result$cluster),
    n_noise = sum(result$cluster == 0)
  )
}
```

### Extract Cluster Centroids

```{r}
get_centroids <- function(stays_df, cluster_col) {
  stays_df |>
    filter(.data[[cluster_col]] > 0) |>
    group_by(.data[[cluster_col]]) |>
    summarize(
      lat = median(lat),
      lon = median(lon),
      total_dwell_hrs = sum(dwell_mins) / 60,
      n_stays = n(),
      n_days = n_distinct(as.Date(start_time)),
      .groups = "drop"
    ) |>
    rename(cluster_id = 1)
}
```

### Deduplicate Ground Truth Locations

```{r}
dedupe_locations <- function(df, threshold_m = DEDUPE_THRESHOLD) {
  if (nrow(df) < 2) {
    return(df |> mutate(location_id = 1))
  }

  coords <- cbind(df$lon, df$lat)
  dist_mat <- distm(coords, coords, fun = distHaversine)
  clusters <- dbscan(as.dist(dist_mat), eps = threshold_m, minPts = 1)

  df |>
    mutate(location_id = clusters$cluster) |>
    group_by(location_id) |>
    summarize(
      lat = median(lat),
      lon = median(lon),
      n_reports = n(),
      intake = max(intake),
      .groups = "drop"
    )
}
```

### Precision / Recall / F1

```{r}
calculate_capture <- function(centroids, gt_locations,
                              threshold_m = PROXIMITY_THRESHOLD) {
  if (nrow(centroids) == 0 || nrow(gt_locations) == 0) {
    return(list(
      recall = 0, precision = 0, f1 = 0,
      n_captured = 0, n_valid_centroids = 0,
      n_ground_truth = nrow(gt_locations),
      n_centroids = nrow(centroids)
    ))
  }

  centroid_coords <- cbind(centroids$lon, centroids$lat)
  gt_coords <- cbind(gt_locations$lon, gt_locations$lat)

  # Recall: fraction of GT locations with a nearby centroid
  captured <- 0
  for (i in seq_len(nrow(gt_locations))) {
    distances <- distHaversine(gt_coords[i, ], centroid_coords)
    if (min(distances) <= threshold_m) captured <- captured + 1
  }
  recall <- captured / nrow(gt_locations)

  # Precision: fraction of centroids near a GT location
  valid_centroids <- 0
  for (i in seq_len(nrow(centroids))) {
    distances <- distHaversine(centroid_coords[i, ], gt_coords)
    if (min(distances) <= threshold_m) valid_centroids <- valid_centroids + 1
  }
  precision <- valid_centroids / nrow(centroids)

  # F1 score
  f1 <- if (precision + recall > 0) {
    2 * (precision * recall) / (precision + recall)
  } else {
    0
  }

  list(
    recall = recall, precision = precision, f1 = f1,
    n_captured = captured, n_valid_centroids = valid_centroids,
    n_ground_truth = nrow(gt_locations),
    n_centroids = nrow(centroids)
  )
}
```

## Run Stay Detection for Each Dwell Threshold

```{r}
stays_by_threshold <- future_map(
  set_names(DWELL_THRESHOLDS),
  \(thresh) detect_stays(gps_data, time_threshold = thresh),
  .options = furrr_options(seed = TRUE)
)
```

Summary stats per threshold:

```{r}
map_dfr(DWELL_THRESHOLDS, \(thresh) {
  s <- stays_by_threshold[[as.character(thresh)]]
  tibble(
    dwell_threshold = thresh,
    n_stays = nrow(s),
    n_subjects = n_distinct(s$subid),
    median_dwell_mins = round(median(s$dwell_mins), 1),
    mean_dwell_mins = round(mean(s$dwell_mins), 1),
    median_points = median(s$n_points)
  )
}) |>
  knitr::kable()
```

## Run DBSCAN Clustering + Extract Centroids

Iterate over the full parameter grid. For each combo, pull the
pre-computed stays for that dwell threshold, cluster per subject,
and extract centroids. Only centroids are retained (not full
cluster assignments) to keep memory manageable across 64 combos.

```{r}
centroids_all <- future_pmap_dfr(param_grid, \(dwell_threshold, eps_meters, min_pts) {
  stays <- stays_by_threshold[[as.character(dwell_threshold)]]

  map_dfr(group_split(stays, subid), \(subj_stays) {
    sub <- unique(subj_stays$subid)

    if (nrow(subj_stays) < 2) {
      subj_stays <- subj_stays |> mutate(cluster = 1L)
    } else {
      coords <- cbind(subj_stays$lon, subj_stays$lat)
      db <- run_dbscan(coords, eps = eps_meters, min_pts = min_pts)
      subj_stays <- subj_stays |> mutate(cluster = db$cluster)
    }

    get_centroids(subj_stays, "cluster") |>
      mutate(
        subid = sub,
        dwell_threshold = dwell_threshold,
        eps_meters = eps_meters,
        min_pts = min_pts,
        .before = 1
      )
  })
}, .options = furrr_options(seed = TRUE))

nrow(centroids_all)
```

## Prepare Ground Truth

### Deduplicate per subject

```{r}
gt_deduped <- locs_gt |>
  group_by(subid) |>
  group_modify(~ dedupe_locations(.x)) |>
  ungroup()
```

### Two GT sets: all locations vs intake-only

```{r}
gt_all <- gt_deduped
gt_intake <- gt_deduped |> filter(intake == 1)
gt_no_intake <- gt_deduped |> filter(intake == 0)

tibble(
  gt_set = c("All locations", "Intake only", "No Intake"),
  n_locations = c(nrow(gt_all), nrow(gt_intake), nrow(gt_no_intake)),
  n_subjects = c(
    n_distinct(gt_all$subid),
    n_distinct(gt_intake$subid),
    n_distinct(gt_no_intake$subid)
    )
  ) |>
  knitr::kable()
```

### Filter GT to locations visited during study

Remove GT locations with no raw GPS data nearby. This is
parameter-independent — it uses raw GPS points rather than
derived stays, avoiding circular dependency with the dwell
threshold being evaluated.

```{r}
filter_gt_by_gps <- function(gt_df, gps_df,
                             threshold_m = PROXIMITY_THRESHOLD) {
  subjects <- unique(gt_df$subid)

  keep <- future_map_dfr(subjects, \(sub) {
    sub_gt <- gt_df |> filter(subid == sub)
    sub_gps <- gps_df |> filter(subid == sub)

    if (nrow(sub_gps) == 0) {
      return(sub_gt |> mutate(has_nearby_gps = FALSE))
    }

    gt_coords <- cbind(sub_gt$lon, sub_gt$lat)
    gps_coords <- cbind(sub_gps$lon, sub_gps$lat)
    dist_mat <- distm(gt_coords, gps_coords, fun = distHaversine)
    sub_gt |> mutate(has_nearby_gps = apply(dist_mat, 1, min) <= threshold_m)
  }, .options = furrr_options(seed = TRUE))

  keep |>
    filter(has_nearby_gps) |>
    select(-has_nearby_gps)
}

gt_all <- filter_gt_by_gps(gt_all, gps_data)
gt_intake <- filter_gt_by_gps(gt_intake, gps_data)
gt_no_intake <- filter_gt_by_gps(gt_no_intake, gps_data)


tibble(
  gt_set = c(
    "All locations (GPS-verified)",
    "Intake only (GPS-verified)",
    "No Intake (GPS-verified)"
  ),
  n_locations = c(nrow(gt_all), nrow(gt_intake), nrow(gt_no_intake)),
  n_subjects = c(
    n_distinct(gt_all$subid),
    n_distinct(gt_intake$subid),
    n_distinct(gt_no_intake$subid)
  )
) |>
  knitr::kable()
```

## Evaluate: Compare Clusters to Ground Truth

```{r}
evaluate_params <- function(dwell_threshold, eps_meters, min_pts,
                            gt_df, gt_label) {
  centroids <- centroids_all |>
    filter(
      dwell_threshold == !!dwell_threshold,
      eps_meters == !!eps_meters,
      min_pts == !!min_pts
    )
  subjects <- intersect(unique(centroids$subid), unique(gt_df$subid))

  future_map_dfr(subjects, \(sub) {
    sub_centroids <- centroids |> filter(subid == sub)
    sub_gt <- gt_df |> filter(subid == sub)

    if (nrow(sub_gt) == 0) return(NULL)

    capture <- calculate_capture(sub_centroids, sub_gt)

    tibble(
      subid = sub,
      dwell_threshold = dwell_threshold,
      eps_meters = eps_meters,
      min_pts = min_pts,
      gt_type = gt_label,
      precision = capture$precision,
      recall = capture$recall,
      f1 = capture$f1,
      n_centroids = capture$n_centroids,
      n_ground_truth = capture$n_ground_truth
    )
  }, .options = furrr_options(seed = TRUE))
}
```

```{r}
gt_sets <- list(
  list(df = gt_all, label = "All Locations"),
  list(df = gt_intake, label = "Intake Only"),
  list(df = gt_no_intake, label = "No Intake")
)

comparison <- map_dfr(gt_sets, \(gt) {
  pmap_dfr(param_grid, \(dwell_threshold, eps_meters, min_pts) {
    evaluate_params(dwell_threshold, eps_meters, min_pts,
                    gt$df, gt$label)
  })
})

comparison <- comparison |>
  mutate(gt_type = factor(gt_type,
                          levels = c("All Locations", "Intake Only", "No Intake")))
nrow(comparison)
```

## Results

### Summary Table

```{r}
summary_table <- comparison |>
  group_by(dwell_threshold, eps_meters, min_pts, gt_type) |>
  summarize(
    n_subjects = n(),
    mean_precision = round(mean(precision), 3),
    mean_recall = round(mean(recall), 3),
    mean_f1 = round(mean(f1), 3),
    sd_f1 = round(sd(f1), 3),
    .groups = "drop"
  ) |>
  arrange(gt_type, desc(mean_f1))

summary_table |>
  knitr::kable(
    col.names = c("Dwell (min)", "Eps (m)", "MinPts", "GT Type", "N",
                  "Precision", "Recall", "F1", "SD(F1)")
  )
```

### Best Parameters per GT Type

```{r}
best_params <- summary_table |>
  group_by(gt_type) |>
  slice_max(mean_f1, n = 1, with_ties = FALSE) |>
  ungroup()

best_params |>
  knitr::kable(
    col.names = c("Dwell (min)", "Eps (m)", "MinPts", "GT Type", "N",
                  "Precision", "Recall", "F1", "SD(F1)")
  )
```

### F1 Heatmap

Mean F1 across eps × minPts, faceted by dwell threshold (columns) and
ground truth type (rows).

```{r}
#| fig-width: 12
#| fig-height: 9
summary_table |>
  ggplot(aes(x = factor(eps_meters), y = factor(min_pts),
             fill = mean_f1)) +
  geom_tile(color = "white", linewidth = 0.5) +
  geom_text(aes(label = sprintf("%.2f", mean_f1)), size = 3) +
  scale_fill_viridis_c(labels = scales::percent, limits = c(0, 1),
                       option = "magma", direction = -1) +
  facet_grid(rows = vars(gt_type), cols = vars(dwell_threshold),
             labeller = labeller(
               dwell_threshold = \(x) paste0(x, " min"),
               gt_type = label_value
             )) +
  labs(
    title = "Mean F1 Score: eps x minPts (faceted by dwell threshold & GT type)",
    x = "eps (meters)",
    y = "minPts",
    fill = "Mean F1"
  ) +
  theme(legend.position = "bottom")
```

### Precision Heatmap

```{r}
#| fig-width: 12
#| fig-height: 9
summary_table |>
  ggplot(aes(x = factor(eps_meters), y = factor(min_pts),
             fill = mean_precision)) +
  geom_tile(color = "white", linewidth = 0.5) +
  geom_text(aes(label = sprintf("%.2f", mean_precision)), size = 3) +
  scale_fill_viridis_c(labels = scales::percent, limits = c(0, 1),
                       option = "magma", direction = -1) +
  facet_grid(rows = vars(gt_type), cols = vars(dwell_threshold),
             labeller = labeller(
               dwell_threshold = \(x) paste0(x, " min"),
               gt_type = label_value
             )) +
  labs(
    title = "Mean Precision: eps x minPts (faceted by dwell threshold & GT type)",
    x = "eps (meters)",
    y = "minPts",
    fill = "Precision"
  ) +
  theme(legend.position = "bottom")
```

### Recall Heatmap

```{r}
#| fig-width: 12
#| fig-height: 9
summary_table |>
  ggplot(aes(x = factor(eps_meters), y = factor(min_pts),
             fill = mean_recall)) +
  geom_tile(color = "white", linewidth = 0.5) +
  geom_text(aes(label = sprintf("%.2f", mean_recall)), size = 3) +
  scale_fill_viridis_c(labels = scales::percent, limits = c(0, 1),
                       option = "magma", direction = -1) +
  facet_grid(rows = vars(gt_type), cols = vars(dwell_threshold),
             labeller = labeller(
               dwell_threshold = \(x) paste0(x, " min"),
               gt_type = label_value
             )) +
  labs(
    title = "Mean Recall: eps x minPts (faceted by dwell threshold & GT type)",
    x = "eps (meters)",
    y = "minPts",
    fill = "Recall"
  ) +
  theme(legend.position = "bottom")
```

### Per-Subject F1 Distribution (Best Params)

Boxplots for the best parameter combination per GT type only, to
keep the plot readable.

```{r}
best_comparison <- comparison |>
  semi_join(best_params,
            by = c("dwell_threshold", "eps_meters", "min_pts", "gt_type"))

best_comparison |>
  mutate(
    param_label = paste0("dwell=", dwell_threshold,
                         ", eps=", eps_meters,
                         ", minPts=", min_pts)
  ) |>
  ggplot(aes(x = gt_type, y = f1, fill = gt_type)) +
  geom_boxplot(width = 0.6, alpha = 0.7, outlier.alpha = 0.4) +
  geom_text(
    data = best_comparison |>
      distinct(gt_type, dwell_threshold, eps_meters, min_pts) |>
      mutate(param_label = paste0("dwell=", dwell_threshold,
                                  ", eps=", eps_meters,
                                  ", minPts=", min_pts)),
    aes(x = gt_type, y = 1.05, label = param_label),
    inherit.aes = FALSE, size = 3
  ) +
  scale_y_continuous(labels = scales::percent, limits = c(0, 1.1)) +
  labs(
    title = "Per-Subject F1 Distribution (Best Params per GT Type)",
    x = "Ground Truth Type",
    y = "F1 Score"
  ) +
  theme(legend.position = "none")
```

### Field Recommendation

In health and mobility GPS research, minimum dwell times of 5--10
minutes are standard (Thierry et al., 2013; Boruff et al., 2012).
Shorter thresholds (2 min) risk capturing transient stops (e.g.,
traffic lights) as stays, inflating cluster count and reducing
precision. Longer thresholds (15 min) may miss brief but meaningful
visits, reducing recall. The heatmaps above show how eps and minPts
interact with dwell threshold, enabling informed parameter selection
for this study's context.

## Bipartite Matching Comparison

The nearest-neighbor evaluation above allows many-to-one matching:
multiple centroids can claim the same GT location, and multiple GT
locations can be captured by the same centroid. This inflates
precision when GT locations are dense. Bipartite (Hungarian)
matching enforces one-to-one assignment, giving a stricter measure
of how well centroids and GT locations correspond.

### Bipartite Capture Function

```{r}
calculate_capture_bipartite <- function(centroids, gt_locations,
                                        threshold_m = PROXIMITY_THRESHOLD) {
  if (nrow(centroids) == 0 || nrow(gt_locations) == 0) {
    return(list(
      recall = 0, precision = 0, f1 = 0,
      n_matched = 0,
      n_ground_truth = nrow(gt_locations),
      n_centroids = nrow(centroids)
    ))
  }

  centroid_coords <- cbind(centroids$lon, centroids$lat)
  gt_coords <- cbind(gt_locations$lon, gt_locations$lat)
  dist_mat <- distm(centroid_coords, gt_coords, fun = distHaversine)

  # Binary eligibility: 1 if within threshold, 0 otherwise
  eligible <- ifelse(dist_mat <= threshold_m, 1, 0)

  nc <- nrow(centroids)
  ng <- nrow(gt_locations)

  # solve_LSAP requires ncol >= nrow
  if (nc <= ng) {
    assignment <- solve_LSAP(eligible, maximum = TRUE)
    matched_pairs <- cbind(seq_len(nc), as.integer(assignment))
  } else {
    assignment <- solve_LSAP(t(eligible), maximum = TRUE)
    matched_pairs <- cbind(as.integer(assignment), seq_len(ng))
  }

  n_matched <- sum(eligible[matched_pairs] == 1)

  precision <- n_matched / nc
  recall <- n_matched / ng
  f1 <- if (precision + recall > 0) {
    2 * (precision * recall) / (precision + recall)
  } else {
    0
  }

  list(
    recall = recall, precision = precision, f1 = f1,
    n_matched = n_matched,
    n_ground_truth = ng,
    n_centroids = nc
  )
}
```

### Bipartite Evaluation

```{r}
evaluate_params_bipartite <- function(dwell_threshold, eps_meters, min_pts,
                                      gt_df, gt_label) {
  centroids <- centroids_all |>
    filter(
      dwell_threshold == !!dwell_threshold,
      eps_meters == !!eps_meters,
      min_pts == !!min_pts
    )
  subjects <- intersect(unique(centroids$subid), unique(gt_df$subid))

  future_map_dfr(subjects, \(sub) {
    sub_centroids <- centroids |> filter(subid == sub)
    sub_gt <- gt_df |> filter(subid == sub)

    if (nrow(sub_gt) == 0) return(NULL)

    capture <- calculate_capture_bipartite(sub_centroids, sub_gt)

    tibble(
      subid = sub,
      dwell_threshold = dwell_threshold,
      eps_meters = eps_meters,
      min_pts = min_pts,
      gt_type = gt_label,
      precision = capture$precision,
      recall = capture$recall,
      f1 = capture$f1,
      n_centroids = capture$n_centroids,
      n_ground_truth = capture$n_ground_truth
    )
  }, .options = furrr_options(seed = TRUE))
}
```

```{r}
comparison_bipartite <- map_dfr(gt_sets, \(gt) {
  pmap_dfr(param_grid, \(dwell_threshold, eps_meters, min_pts) {
    evaluate_params_bipartite(dwell_threshold, eps_meters, min_pts,
                              gt$df, gt$label)
  })
})

comparison_bipartite <- comparison_bipartite |>
  mutate(gt_type = factor(gt_type,
                          levels = c("All Locations", "Intake Only", "No Intake")))
nrow(comparison_bipartite)
```

### Bipartite Summary

```{r}
summary_bipartite <- comparison_bipartite |>
  group_by(dwell_threshold, eps_meters, min_pts, gt_type) |>
  summarize(
    n_subjects = n(),
    mean_precision = round(mean(precision), 3),
    mean_recall = round(mean(recall), 3),
    mean_f1 = round(mean(f1), 3),
    sd_f1 = round(sd(f1), 3),
    .groups = "drop"
  ) |>
  arrange(gt_type, desc(mean_f1))

best_params_bipartite <- summary_bipartite |>
  group_by(gt_type) |>
  slice_max(mean_f1, n = 1, with_ties = FALSE) |>
  ungroup()

best_params_bipartite |>
  knitr::kable(
    col.names = c("Dwell (min)", "Eps (m)", "MinPts", "GT Type", "N",
                  "Precision", "Recall", "F1", "SD(F1)")
  )
```

### Method Comparison: NN vs Bipartite

```{r}
method_comparison <- inner_join(
  summary_table |>
    select(dwell_threshold, eps_meters, min_pts, gt_type,
           mean_precision, mean_recall, mean_f1) |>
    rename(precision_nn = mean_precision,
           recall_nn = mean_recall,
           f1_nn = mean_f1),
  summary_bipartite |>
    select(dwell_threshold, eps_meters, min_pts, gt_type,
           mean_precision, mean_recall, mean_f1) |>
    rename(precision_bp = mean_precision,
           recall_bp = mean_recall,
           f1_bp = mean_f1),
  by = c("dwell_threshold", "eps_meters", "min_pts", "gt_type")
) |>
  mutate(
    precision_delta = precision_nn - precision_bp,
    recall_delta = recall_nn - recall_bp,
    f1_delta = f1_nn - f1_bp
  )

method_comparison |>
  group_by(gt_type) |>
  summarize(
    mean_precision_inflation = round(mean(precision_delta), 3),
    mean_recall_inflation = round(mean(recall_delta), 3),
    mean_f1_inflation = round(mean(f1_delta), 3),
    max_precision_inflation = round(max(precision_delta), 3),
    .groups = "drop"
  ) |>
  knitr::kable()
```

### Bipartite F1 Heatmap

```{r}
#| fig-width: 12
#| fig-height: 9
summary_bipartite |>
  ggplot(aes(x = factor(eps_meters), y = factor(min_pts),
             fill = mean_f1)) +
  geom_tile(color = "white", linewidth = 0.5) +
  geom_text(aes(label = sprintf("%.2f", mean_f1)), size = 3) +
  scale_fill_viridis_c(labels = scales::percent, limits = c(0, 1),
                       option = "magma", direction = -1) +
  facet_grid(rows = vars(gt_type), cols = vars(dwell_threshold),
             labeller = labeller(
               dwell_threshold = \(x) paste0(x, " min"),
               gt_type = label_value
             )) +
  labs(
    title = "Bipartite F1: eps x minPts (faceted by dwell threshold & GT type)",
    x = "eps (meters)",
    y = "minPts",
    fill = "Mean F1"
  ) +
  theme(legend.position = "bottom")
```

### Bipartite Precision Heatmap

```{r}
#| fig-width: 12
#| fig-height: 9
summary_bipartite |>
  ggplot(aes(x = factor(eps_meters), y = factor(min_pts),
             fill = mean_precision)) +
  geom_tile(color = "white", linewidth = 0.5) +
  geom_text(aes(label = sprintf("%.2f", mean_precision)), size = 3) +
  scale_fill_viridis_c(labels = scales::percent, limits = c(0, 1),
                       option = "magma", direction = -1) +
  facet_grid(rows = vars(gt_type), cols = vars(dwell_threshold),
             labeller = labeller(
               dwell_threshold = \(x) paste0(x, " min"),
               gt_type = label_value
             )) +
  labs(
    title = "Bipartite Precision: eps x minPts (faceted by dwell threshold & GT type)",
    x = "eps (meters)",
    y = "minPts",
    fill = "Precision"
  ) +
  theme(legend.position = "bottom")
```

### Save Bipartite Results

```{r}
write_csv(comparison_bipartite,
          here::here(path_gps2, "data/dbscan_param_comparison_bipartite.csv"))
```

## Diagnostics

### NN vs Bipartite Precision Inflation

How much does nearest-neighbor matching inflate metrics compared to
bipartite, now that GT is GPS-verified?

```{r}
method_comparison |>
  group_by(gt_type) |>
  summarize(
    mean_precision_inflation = round(mean(precision_delta), 3),
    mean_recall_inflation = round(mean(recall_delta), 3),
    mean_f1_inflation = round(mean(f1_delta), 3),
    max_precision_inflation = round(max(precision_delta), 3),
    .groups = "drop"
  ) |>
  knitr::kable()
```

Inflation by parameter combo for intake-only (sorted by largest
precision gap):

```{r}
method_comparison |>
  filter(gt_type == "Intake Only") |>
  arrange(desc(precision_delta)) |>
  select(dwell_threshold, eps_meters, min_pts,
         precision_nn, precision_bp, precision_delta,
         f1_nn, f1_bp, f1_delta) |>
  head(10) |>
  knitr::kable(digits = 3)
```

### GT Locations per Subject After GPS Filter

How many intake GT locations survive per subject? Sparse GT makes
per-subject F1 noisy — a single missed match can swing F1
substantially.

```{r}
gt_intake_per_sub <- gt_intake |>
  count(subid, name = "n_gt_locations")

gt_intake_per_sub |>
  summarize(
    n_subjects = n(),
    mean_locs = round(mean(n_gt_locations), 1),
    median_locs = median(n_gt_locations),
    min_locs = min(n_gt_locations),
    max_locs = max(n_gt_locations),
    pct_3_or_fewer = round(mean(n_gt_locations <= 3) * 100, 1)
  ) |>
  knitr::kable()
```

```{r}
gt_intake_per_sub |>
  ggplot(aes(x = n_gt_locations)) +
  geom_histogram(binwidth = 1, fill = "steelblue", color = "white") +
  labs(
    title = "Intake GT Locations per Subject (GPS-Verified)",
    x = "Number of GT Locations",
    y = "Number of Subjects"
  )
```

### Matching Threshold Sensitivity

Is 100m the right threshold? Test 50m to 250m in 25m increments
using the best bipartite intake-only params to see how F1 changes.

```{r}
best_intake <- best_params_bipartite |>
  filter(gt_type == "Intake Only")

best_centroids <- centroids_all |>
  filter(
    dwell_threshold == best_intake$dwell_threshold,
    eps_meters == best_intake$eps_meters,
    min_pts == best_intake$min_pts
  )

thresholds_to_test <- seq(50, 250, by = 25)

threshold_sensitivity <- map_dfr(thresholds_to_test, \(thresh) {
  subjects <- intersect(unique(best_centroids$subid),
                        unique(gt_intake$subid))

  sub_results <- future_map_dfr(subjects, \(sub) {
    sub_centroids <- best_centroids |> filter(subid == sub)
    sub_gt <- gt_intake |> filter(subid == sub)

    if (nrow(sub_gt) == 0) return(NULL)

    capture <- calculate_capture_bipartite(sub_centroids, sub_gt,
                                           threshold_m = thresh)
    tibble(
      subid = sub,
      precision = capture$precision,
      recall = capture$recall,
      f1 = capture$f1
    )
  }, .options = furrr_options(seed = TRUE))

  sub_results |>
    summarize(
      threshold_m = thresh,
      mean_precision = round(mean(precision), 3),
      mean_recall = round(mean(recall), 3),
      mean_f1 = round(mean(f1), 3)
    )
})

threshold_sensitivity |>
  knitr::kable(col.names = c("Threshold (m)", "Precision", "Recall", "F1"))
```

```{r}
threshold_sensitivity |>
  pivot_longer(cols = c(mean_precision, mean_recall, mean_f1),
               names_to = "metric", values_to = "value") |>
  mutate(metric = case_match(metric,
    "mean_precision" ~ "Precision",
    "mean_recall" ~ "Recall",
    "mean_f1" ~ "F1"
  )) |>
  ggplot(aes(x = threshold_m, y = value, color = metric)) +
  geom_line(linewidth = 1) +
  geom_point(size = 3) +
  scale_y_continuous(labels = scales::percent, limits = c(0, 1)) +
  scale_x_continuous(breaks = thresholds_to_test) +
  labs(
    title = "Bipartite Metrics by Matching Threshold (Intake Only, Best Params)",
    x = "Matching Threshold (meters)",
    y = "Score",
    color = "Metric"
  ) +
  theme(legend.position = "bottom")
```
