---
title: "Greenspace & Landuse Enrichment Exploration"
author: "Christopher Janssen"
date: "`r lubridate::today()`"
format:
  html:
    self-contained: true
    toc: true
    toc-depth: 3
    code-fold: show
editor_options:
  chunk_output_type: console
---

# Overview

This notebook demonstrates **landuse polygon enrichment** for GPS data - currently NOT implemented in the enrichment pipeline.

**Goals:**

1. Demo point-in-polygon matching with OSM landuse data
2. Calculate time spent in parks/nature vs. built environment
3. Measure park accessibility (distance to nearest park)
4. Show research value of adding landuse metadata

## Setup

```{r setup}
#| message: false
#| warning: false

source(here::here("scripts/r/setup.R"))
source(here::here("scripts/r/connection.R"))
```

## Database Connection

```{r}
# Connect to database
con <- connect_to_db()

# Verify connection
dbGetQuery(con, "SELECT current_database(), current_user")
```

# Landuse Data Overview

First, let's understand what landuse polygons are available.

## Landuse Classes

```{r}
# Get counts by class
landuse_classes <- dbGetQuery(con, "
SELECT
  class,
  COUNT(*) as n_polygons,
  COUNT(DISTINCT type) as n_types,
  ROUND(SUM(area_sqkm)::numeric, 2) as total_area_sqkm
FROM public_data.osm_landuse
GROUP BY class
ORDER BY n_polygons DESC;
")

landuse_classes |>
  knitr::kable(
    col.names = c("Class", "Polygons", "Unique Types", "Total Area (km²)"),
    format.args = list(big.mark = ",")
  )
```

## Greenspace Types

Focus on greenspace categories: parks, natural areas, recreation.

```{r}
# Get greenspace types
greenspace_types <- dbGetQuery(con, "
SELECT
  class,
  type,
  COUNT(*) as n_polygons,
  ROUND(AVG(area_sqkm)::numeric, 4) as avg_area_sqkm,
  ROUND(SUM(area_sqkm)::numeric, 2) as total_area_sqkm
FROM public_data.osm_landuse
WHERE (class = 'leisure' AND type IN ('park', 'nature_reserve', 'garden', 'golf_course', 'sports_centre'))
   OR (class = 'natural' AND type IN ('wood', 'forest', 'grassland', 'water', 'wetland', 'scrub'))
   OR (class = 'landuse' AND type IN ('forest', 'grass', 'meadow', 'recreation_ground'))
GROUP BY class, type
ORDER BY n_polygons DESC;
")

greenspace_types |>
  knitr::kable(
    col.names = c("Class", "Type", "Count", "Avg Area (km²)", "Total Area (km²)"),
    format.args = list(big.mark = ",")
  )
```

# GPS Sample

Pull sample of stationary GPS points for enrichment.

```{r}
# Get 10,000 stationary points with dwell time
gps_sample <- dbGetQuery(con, "
SELECT
  processed_id,
  subid,
  lat,
  lon,
  time_local,
  is_stationary,
  dwell_time_seconds,
  dwell_time_seconds / 3600.0 as dwell_hours,
  geom
FROM risk1.processed_gps
WHERE is_stationary = TRUE
  AND dwell_time_seconds IS NOT NULL
LIMIT 10000;
")

nrow(gps_sample)
```

```{r}
# Sample summary
gps_sample |>
  summarise(
    n_subjects = n_distinct(subid),
    n_points = n(),
    total_hours = sum(dwell_hours, na.rm = TRUE),
    avg_dwell_min = mean(dwell_time_seconds / 60, na.rm = TRUE)
  ) |>
  knitr::kable(
    col.names = c("Subjects", "GPS Points", "Total Hours", "Avg Dwell (min)"),
    digits = 1
  )
```

# Landuse Enrichment

Add landuse context to GPS points using point-in-polygon matching.

## Point-in-Polygon Matching

```{r}
# Match GPS points to landuse polygons
# This query finds which landuse polygon (if any) contains each GPS point
gps_landuse <- dbGetQuery(con, "
WITH gps_points AS (
  SELECT
    processed_id,
    subid,
    dwell_time_seconds,
    geom
  FROM risk1.processed_gps
  WHERE is_stationary = TRUE
    AND dwell_time_seconds IS NOT NULL
  LIMIT 10000
)
SELECT
  g.processed_id,
  g.subid,
  g.dwell_time_seconds,
  g.dwell_time_seconds / 3600.0 as dwell_hours,
  l.class as landuse_class,
  l.type as landuse_type,
  l.area_sqkm as landuse_area_sqkm
FROM gps_points g
LEFT JOIN public_data.osm_landuse l
  ON ST_Within(g.geom, l.geom)
;
")

nrow(gps_landuse)
```

```{r}
# Match rate
tibble(
  total_points = 10000,
  matched_to_landuse = sum(!is.na(gps_landuse$landuse_class)),
  match_rate_pct = round(100 * sum(!is.na(gps_landuse$landuse_class)) / 10000, 1)
)
```

## Landuse Frequency

```{r}
# Count GPS points in each landuse type
landuse_freq <- gps_landuse |>
  filter(!is.na(landuse_class)) |>
  count(landuse_class, landuse_type, sort = TRUE) |>
  mutate(pct = round(100 * n / sum(n), 2))

landuse_freq |>
  slice_head(n = 30) |>
  knitr::kable(
    col.names = c("Class", "Type", "GPS Points", "% of Matched"),
    format.args = list(big.mark = ",")
  )
```

# Greenspace Analysis

Focus on parks and natural areas.

## Define Greenspace Categories

```{r}
# Categorize landuse into greenspace types
gps_greenspace <- gps_landuse |>
  mutate(
    greenspace_category = case_when(
      # Parks and recreation
      landuse_class == "leisure" & landuse_type %in% c("park", "nature_reserve", "garden") ~ "Parks",
      landuse_class == "leisure" & landuse_type %in% c("golf_course", "sports_centre", "pitch") ~ "Sports/Recreation",
      # Natural areas
      landuse_class == "natural" & landuse_type %in% c("wood", "forest") ~ "Forest",
      landuse_class == "natural" & landuse_type == "water" ~ "Water",
      landuse_class == "natural" & landuse_type %in% c("grassland", "meadow", "scrub") ~ "Natural Grassland",
      landuse_class == "natural" & landuse_type == "wetland" ~ "Wetland",
      landuse_class == "landuse" & landuse_type %in% c("forest", "grass", "meadow", "recreation_ground") ~ "Green Landuse",
      # Built environment
      landuse_class == "landuse" & landuse_type %in% c("residential", "commercial", "industrial", "retail") ~ "Built Environment",
      # Other
      !is.na(landuse_class) ~ "Other Landuse",
      TRUE ~ "No Landuse Match"
    ),
    is_greenspace = greenspace_category %in% c("Parks", "Sports/Recreation", "Forest", "Water", "Natural Grassland", "Wetland", "Green Landuse")
  )

# Sanity check
gps_greenspace |>
  count(greenspace_category, is_greenspace) |>
  knitr::kable()
```

## Time in Parks/Nature

Calculate time spent in greenspace vs. built environment.

```{r}
# Aggregate time by greenspace category
time_by_greenspace <- gps_greenspace |>
  group_by(greenspace_category) |>
  summarise(
    n_points = n(),
    total_hours = sum(dwell_hours, na.rm = TRUE),
    .groups = "drop"
  ) |>
  mutate(
    pct_points = round(100 * n_points / sum(n_points), 2),
    pct_time = round(100 * total_hours / sum(total_hours), 2)
  ) |>
  arrange(desc(total_hours))

time_by_greenspace |>
  knitr::kable(
    col.names = c("Environment Type", "GPS Points", "Total Hours", "% Points", "% Time"),
    format.args = list(big.mark = ","),
    digits = 1
  )
```

```{r}
# Greenspace vs. built environment summary
greenspace_summary <- gps_greenspace |>
  mutate(
    environment = case_when(
      is_greenspace ~ "Greenspace (Parks/Nature)",
      greenspace_category == "Built Environment" ~ "Built Environment",
      greenspace_category == "No Landuse Match" ~ "No Landuse Data",
      TRUE ~ "Other"
    )
  ) |>
  group_by(environment) |>
  summarise(
    n_points = n(),
    total_hours = sum(dwell_hours, na.rm = TRUE),
    .groups = "drop"
  ) |>
  mutate(
    pct_points = round(100 * n_points / sum(n_points), 2),
    pct_time = round(100 * total_hours / sum(total_hours), 2)
  ) |>
  arrange(desc(total_hours))

greenspace_summary |>
  knitr::kable(
    col.names = c("Environment", "GPS Points", "Total Hours", "% Points", "% Time"),
    format.args = list(big.mark = ","),
    digits = 1
  )
```

## Subject-Level Greenspace Exposure

```{r}
# Calculate greenspace exposure per subject
subject_greenspace <- gps_greenspace |>
  group_by(subid) |>
  summarise(
    total_points = n(),
    total_hours = sum(dwell_hours, na.rm = TRUE),
    greenspace_points = sum(is_greenspace, na.rm = TRUE),
    greenspace_hours = sum(dwell_hours[is_greenspace], na.rm = TRUE),
    .groups = "drop"
  ) |>
  mutate(
    pct_time_greenspace = round(100 * greenspace_hours / total_hours, 1)
  ) |>
  arrange(desc(pct_time_greenspace))

# Summary statistics
subject_greenspace |>
  summarise(
    n_subjects = n(),
    avg_pct_greenspace = mean(pct_time_greenspace, na.rm = TRUE),
    median_pct_greenspace = median(pct_time_greenspace, na.rm = TRUE),
    min_pct = min(pct_time_greenspace, na.rm = TRUE),
    max_pct = max(pct_time_greenspace, na.rm = TRUE)
  ) |>
  knitr::kable(
    col.names = c("Subjects", "Mean % Time", "Median % Time", "Min %", "Max %"),
    digits = 1
  )
```

```{r}
# Top 10 subjects by greenspace exposure
subject_greenspace |>
  slice_head(n = 10) |>
  knitr::kable(
    col.names = c("Subject", "Total Points", "Total Hours", "Greenspace Points", "Greenspace Hours", "% Time in Greenspace"),
    digits = 1
  )
```

# Park Accessibility

For GPS points NOT in parks, how far to the nearest park?

## Distance to Nearest Park

```{r}
# Find distance to nearest park for points not in parks
# Focus on leisure=park polygons
park_distance <- dbGetQuery(con, "
WITH gps_points AS (
  SELECT
    processed_id,
    geom
  FROM risk1.processed_gps
  WHERE is_stationary = TRUE
  LIMIT 10000
),
parks AS (
  SELECT
    osm_id,
    type,
    area_sqkm,
    geom
  FROM public_data.osm_landuse
  WHERE class = 'leisure' AND type = 'park'
)
SELECT
  g.processed_id,
  MIN(ST_Distance(g.geom::geography, p.geom::geography)) as nearest_park_distance_m
FROM gps_points g
CROSS JOIN parks p
GROUP BY g.processed_id
;
")

nrow(park_distance)
```

```{r}
# Join with greenspace-categorized GPS data to include greenspace categories
gps_park_access <- gps_greenspace |>
  left_join(park_distance, by = "processed_id") |>
  mutate(
    in_park = !is.na(landuse_class) & landuse_class == "leisure" & landuse_type == "park",
    nearest_park_distance_m = ifelse(in_park, 0, nearest_park_distance_m)
  )

# Distribution summary
gps_park_access |>
  filter(!is.na(nearest_park_distance_m)) |>
  summarise(
    n_points = n(),
    mean_dist_m = mean(nearest_park_distance_m, na.rm = TRUE),
    median_dist_m = median(nearest_park_distance_m, na.rm = TRUE),
    min_dist_m = min(nearest_park_distance_m, na.rm = TRUE),
    max_dist_m = max(nearest_park_distance_m, na.rm = TRUE)
  ) |>
  knitr::kable(
    col.names = c("GPS Points", "Mean (m)", "Median (m)", "Min (m)", "Max (m)"),
    digits = 0,
    format.args = list(big.mark = ",")
  )
```

## Accessibility Thresholds

```{r}
# Calculate % within different distance thresholds
park_access_thresholds <- gps_park_access |>
  filter(!is.na(nearest_park_distance_m)) |>
  summarise(
    total_points = n(),
    in_park = sum(nearest_park_distance_m == 0),
    within_100m = sum(nearest_park_distance_m <= 100),
    within_250m = sum(nearest_park_distance_m <= 250),
    within_500m = sum(nearest_park_distance_m <= 500),
    within_1km = sum(nearest_park_distance_m <= 1000)
  ) |>
  mutate(
    pct_in_park = round(100 * in_park / total_points, 1),
    pct_within_100m = round(100 * within_100m / total_points, 1),
    pct_within_250m = round(100 * within_250m / total_points, 1),
    pct_within_500m = round(100 * within_500m / total_points, 1),
    pct_within_1km = round(100 * within_1km / total_points, 1)
  )

# Reshape for display
tibble(
  threshold = c("In Park (0m)", "Within 100m", "Within 250m", "Within 500m", "Within 1km"),
  count = c(
    park_access_thresholds$in_park,
    park_access_thresholds$within_100m,
    park_access_thresholds$within_250m,
    park_access_thresholds$within_500m,
    park_access_thresholds$within_1km
  ),
  percentage = c(
    park_access_thresholds$pct_in_park,
    park_access_thresholds$pct_within_100m,
    park_access_thresholds$pct_within_250m,
    park_access_thresholds$pct_within_500m,
    park_access_thresholds$pct_within_1km
  )
) |>
  knitr::kable(
    col.names = c("Distance Threshold", "GPS Points", "% of Sample"),
    format.args = list(big.mark = ",")
  )
```

# Combined Environmental Profile

Combine landuse + park accessibility into environmental profile.

```{r}
# Create environmental profile
environmental_profile <- gps_park_access |>
  mutate(
    park_access_category = case_when(
      nearest_park_distance_m == 0 ~ "In Park",
      nearest_park_distance_m <= 250 ~ "Near Park (<250m)",
      nearest_park_distance_m <= 1000 ~ "Moderate Distance (250m-1km)",
      TRUE ~ "Far from Park (>1km)"
    ),
    environment_profile = case_when(
      greenspace_category == "Parks" ~ "In Park",
      greenspace_category %in% c("Forest", "Natural Grassland", "Water", "Wetland") ~ "In Natural Area",
      greenspace_category == "Sports/Recreation" ~ "In Recreation Area",
      greenspace_category == "Built Environment" & park_access_category == "Near Park (<250m)" ~ "Built Environment - Near Park",
      greenspace_category == "Built Environment" & park_access_category != "Near Park (<250m)" ~ "Built Environment - Far from Park",
      greenspace_category == "No Landuse Match" & park_access_category == "Near Park (<250m)" ~ "Unknown Landuse - Near Park",
      greenspace_category == "No Landuse Match" ~ "Unknown Landuse",
      TRUE ~ "Other"
    )
  )

# Summary by profile
environmental_profile |>
  count(environment_profile, sort = TRUE) |>
  mutate(pct = round(100 * n / sum(n), 2)) |>
  knitr::kable(
    col.names = c("Environmental Profile", "GPS Points", "% of Sample"),
    format.args = list(big.mark = ",")
  )
```

# Research Value Summary

## What Landuse Enrichment Provides

**1. Time Allocation Metrics**
- % time in greenspace vs. built environment
- Distinguish parks, forests, water, sports facilities
- Subject-level exposure variability

**2. Accessibility Metrics**
- Distance to nearest park from each location
- Urban greenspace access inequities
- Environmental context for health behaviors

**3. Environmental Typology**
- Classify locations beyond single POI
- Multi-dimensional context (landuse + POI + proximity)
- Better characterization of activity spaces

## Example Use Cases

**Alcohol Research:**
- Do people spend more time at bars in areas far from parks?
- Is greenspace access associated with alcohol venue exposure?
- Are bars more concentrated in built vs. natural environments?

**Health Behaviors:**
- Physical activity opportunities (parks, sports facilities)
- Sedentary time in commercial vs. residential zones
- Natural area exposure and stress/wellbeing

**Environmental Justice:**
- Combine with ADI scores for deprivation + greenspace access
- Urban heat island exposure (pavement vs. tree cover)
- Environmental quality of time-weighted activity spaces

## Implementation Considerations

**Advantages:**
- Point-in-polygon is fast (spatial indexes on both tables)
- No distance threshold needed (polygon containment)
- Rich categorical data (class + type + area)
- Complements POI enrichment (different scale/concept)

**Considerations:**
- Match rate depends on landuse polygon coverage (~40-60% typical)
- Multiple polygons can overlap (may need priority rules)
- Some GPS points fall in unmapped areas (no landuse data)

**Recommendation:**
- **Add landuse enrichment to pipeline** alongside current POI matching
- Focus on: parks, natural areas, built environment categories
- Use for time-weighted exposure metrics, not just presence/absence

# Example Enriched Output

```{r}
# Show what enriched GPS data would look like
enriched_example <- gps_park_access |>
  select(
    processed_id,
    subid,
    dwell_hours,
    landuse_class,
    landuse_type,
    landuse_area_sqkm,
    greenspace_category,
    is_greenspace,
    nearest_park_distance_m
  ) |>
  slice_head(n = 20)

enriched_example |>
  knitr::kable(digits = 2)
```

# Individual Subject Greenspace Profiles

To make greenspace exposure more concrete, let's analyze specific individuals with contrasting patterns.

## Subject Selection for Greenspace Analysis

Find subjects with varying greenspace exposure.

```{r}
# Calculate greenspace exposure for all subjects
subject_greenspace_all <- gps_greenspace |>
  group_by(subid) |>
  summarise(
    total_points = n(),
    total_hours = sum(dwell_hours, na.rm = TRUE),
    greenspace_points = sum(is_greenspace, na.rm = TRUE),
    greenspace_hours = sum(dwell_hours[is_greenspace], na.rm = TRUE),
    park_points = sum(greenspace_category == "Parks", na.rm = TRUE),
    park_hours = sum(dwell_hours[greenspace_category == "Parks"], na.rm = TRUE),
    .groups = "drop"
  ) |>
  filter(total_points >= 50) |>  # Sufficient data
  mutate(
    pct_time_greenspace = round(100 * greenspace_hours / total_hours, 1),
    pct_time_parks = round(100 * park_hours / total_hours, 1)
  ) |>
  arrange(desc(pct_time_greenspace))

# Show distribution
subject_greenspace_all |>
  slice_head(n = 20) |>
  knitr::kable(
    col.names = c("Subject ID", "GPS Points", "Total Hours", "Greenspace Points", "Greenspace Hours", "Park Points", "Park Hours", "% Time Greenspace", "% Time Parks"),
    digits = 1,
    format.args = list(big.mark = ",")
  )
```

```{r}
# Select 3 subjects with contrasting greenspace exposure
# Start with empty tibble in case we can't find subjects
selected_greenspace_subjects <- tibble()

if (nrow(subject_greenspace_all) > 0) {
  # High greenspace subject
  high_gs <- subject_greenspace_all |>
    arrange(desc(pct_time_greenspace)) |>
    slice(1) |>
    mutate(profile = "High Greenspace")

  # Low greenspace subject
  low_gs <- subject_greenspace_all |>
    arrange(pct_time_greenspace) |>
    slice(1) |>
    mutate(profile = "Low Greenspace")

  # Moderate greenspace subject (try to find one, otherwise pick one with good data)
  moderate_gs <- subject_greenspace_all |>
    filter(pct_time_greenspace > 5, pct_time_greenspace < 15) |>
    arrange(desc(total_points)) |>
    slice(1)

  # If no moderate subject found, pick one from middle of distribution
  if (nrow(moderate_gs) == 0 && nrow(subject_greenspace_all) >= 3) {
    moderate_gs <- subject_greenspace_all |>
      arrange(pct_time_greenspace) |>
      slice(n() %/% 2)
  }

  if (nrow(moderate_gs) > 0) {
    moderate_gs <- moderate_gs |> mutate(profile = "Moderate Greenspace")
  }

  # Combine subjects
  selected_greenspace_subjects <- bind_rows(high_gs, low_gs, moderate_gs) |>
    distinct(subid, .keep_all = TRUE) |>
    select(profile, everything())
}

# Display selected subjects
if (nrow(selected_greenspace_subjects) > 0) {
  selected_greenspace_subjects |>
    knitr::kable(
      col.names = c("Profile", "Subject ID", "GPS Points", "Total Hours", "Greenspace Points", "Greenspace Hours", "Park Points", "Park Hours", "% Time Greenspace", "% Time Parks"),
      digits = 1,
      format.args = list(big.mark = ",")
    )
} else {
  cat("No subjects found with sufficient data for greenspace analysis.\n")
}
```

## Individual Greenspace Analysis

Analyze detailed greenspace exposure for each selected subject.

```{r}
# Function to analyze one subject's greenspace exposure
analyze_subject_greenspace <- function(subject_id) {
  # Get subject's GPS points with landuse enrichment
  subject_landuse <- gps_greenspace |>
    filter(subid == subject_id)

  return(subject_landuse)
}

# Analyze each selected subject (only if we found subjects)
if (nrow(selected_greenspace_subjects) > 0) {
  subject_greenspace_analyses <- selected_greenspace_subjects |>
    mutate(
      landuse_data = map(subid, analyze_subject_greenspace)
    )
} else {
  subject_greenspace_analyses <- tibble()
}
```

### Subject 1: High Greenspace Exposure

```{r}
if (nrow(selected_greenspace_subjects) >= 1) {
  subj1_gs_id <- selected_greenspace_subjects$subid[1]
  subj1_gs_data <- subject_greenspace_analyses$landuse_data[[1]]

  cat(sprintf("\n**Subject %d:** %.1f%% of time in greenspace (%.1f hours of %.1f total)\n\n",
              subj1_gs_id,
              selected_greenspace_subjects$pct_time_greenspace[1],
              selected_greenspace_subjects$greenspace_hours[1],
              selected_greenspace_subjects$total_hours[1]))

  # Breakdown by greenspace type
  subj1_gs_breakdown <- subj1_gs_data |>
    filter(is_greenspace) |>
    group_by(greenspace_category) |>
    summarise(
      n_points = n(),
      total_hours = sum(dwell_hours, na.rm = TRUE),
      .groups = "drop"
    ) |>
    mutate(
      pct_of_greenspace_time = round(100 * total_hours / sum(total_hours), 1)
    ) |>
    arrange(desc(total_hours))

  subj1_gs_breakdown |>
    knitr::kable(
      col.names = c("Greenspace Type", "GPS Points", "Hours", "% of Greenspace Time"),
      digits = 1,
      format.args = list(big.mark = ",")
    )

  # Sample GPS records showing greenspace exposure
  if (nrow(subj1_gs_data |> filter(is_greenspace)) > 0) {
    subj1_gs_data |>
      filter(is_greenspace) |>
      select(processed_id, dwell_hours, greenspace_category, landuse_type, landuse_area_sqkm) |>
      slice_head(n = 15) |>
      knitr::kable(
        col.names = c("GPS Point ID", "Dwell (hrs)", "Greenspace Type", "Landuse Type", "Area (km²)"),
        digits = 2
      )
  }
} else {
  cat("Subject 1 data not available.\n")
}
```

### Subject 2: Low Greenspace Exposure

```{r}
if (nrow(selected_greenspace_subjects) >= 2) {
  subj2_gs_id <- selected_greenspace_subjects$subid[2]
  subj2_gs_data <- subject_greenspace_analyses$landuse_data[[2]]

  cat(sprintf("\n**Subject %d:** %.1f%% of time in greenspace (%.1f hours of %.1f total)\n\n",
              subj2_gs_id,
              selected_greenspace_subjects$pct_time_greenspace[2],
              selected_greenspace_subjects$greenspace_hours[2],
              selected_greenspace_subjects$total_hours[2]))

  # Where do they spend time instead?
  subj2_env_breakdown <- subj2_gs_data |>
    group_by(greenspace_category) |>
    summarise(
      n_points = n(),
      total_hours = sum(dwell_hours, na.rm = TRUE),
      .groups = "drop"
    ) |>
    mutate(
      pct_of_time = round(100 * total_hours / sum(total_hours), 1)
    ) |>
    arrange(desc(total_hours))

  subj2_env_breakdown |>
    knitr::kable(
      col.names = c("Environment Type", "GPS Points", "Hours", "% of Time"),
      digits = 1,
      format.args = list(big.mark = ",")
    )
}
```

### Subject 3: Moderate Greenspace Exposure

```{r}
if (nrow(selected_greenspace_subjects) >= 3) {
  subj3_gs_id <- selected_greenspace_subjects$subid[3]
  subj3_gs_data <- subject_greenspace_analyses$landuse_data[[3]]

  cat(sprintf("\n**Subject %d:** %.1f%% of time in greenspace (%.1f hours of %.1f total)\n\n",
              subj3_gs_id,
              selected_greenspace_subjects$pct_time_greenspace[3],
              selected_greenspace_subjects$greenspace_hours[3],
              selected_greenspace_subjects$total_hours[3]))

  # Environment breakdown
  subj3_env_breakdown <- subj3_gs_data |>
    group_by(greenspace_category) |>
    summarise(
      n_points = n(),
      total_hours = sum(dwell_hours, na.rm = TRUE),
      .groups = "drop"
    ) |>
    mutate(
      pct_of_time = round(100 * total_hours / sum(total_hours), 1)
    ) |>
    arrange(desc(total_hours))

  subj3_env_breakdown |>
    slice_head(n = 10) |>
    knitr::kable(
      col.names = c("Environment Type", "GPS Points", "Hours", "% of Time"),
      digits = 1,
      format.args = list(big.mark = ",")
    )
} else {
  cat("Subject 3 data not available.\n")
}
```

## Subject Greenspace Comparison

Visual comparison of selected subjects' greenspace exposure.

```{r}
if (nrow(selected_greenspace_subjects) > 0) {
  # Side-by-side comparison
  greenspace_comparison <- selected_greenspace_subjects |>
    select(profile, subid, total_hours, greenspace_hours, pct_time_greenspace, park_hours, pct_time_parks)

  greenspace_comparison |>
    knitr::kable(
      col.names = c("Profile", "Subject ID", "Total Hours", "Greenspace Hours", "% Greenspace", "Park Hours", "% Parks"),
      digits = 1,
      format.args = list(big.mark = ",")
    )
} else {
  cat("No subjects available for comparison.\n")
}
```

```{r}
if (nrow(selected_greenspace_subjects) > 0) {
  # Park accessibility for selected subjects
  subject_park_access <- gps_park_access |>
    filter(subid %in% selected_greenspace_subjects$subid) |>
    group_by(subid) |>
    summarise(
      n_points = n(),
      in_park = sum(nearest_park_distance_m == 0, na.rm = TRUE),
      within_100m = sum(nearest_park_distance_m <= 100, na.rm = TRUE),
      within_500m = sum(nearest_park_distance_m <= 500, na.rm = TRUE),
      avg_park_distance_m = mean(nearest_park_distance_m[nearest_park_distance_m > 0], na.rm = TRUE),
      .groups = "drop"
    ) |>
    mutate(
      pct_in_park = round(100 * in_park / n_points, 1),
      pct_within_100m = round(100 * within_100m / n_points, 1),
      pct_within_500m = round(100 * within_500m / n_points, 1)
    ) |>
    left_join(
      selected_greenspace_subjects |> select(subid, profile),
      by = "subid"
    ) |>
    select(profile, everything())

  subject_park_access |>
    knitr::kable(
      col.names = c("Profile", "Subject ID", "GPS Points", "In Park", "Within 100m", "Within 500m", "Avg Distance (m)", "% In Park", "% <100m", "% <500m"),
      digits = 1,
      format.args = list(big.mark = ",")
    )
} else {
  cat("No subjects available for park accessibility analysis.\n")
}
```

# Recommendations for Meeting

## 1. Add Landuse Polygon Enrichment

**Implement point-in-polygon matching for:**
- Parks (leisure=park)
- Natural areas (natural=wood/forest/water/grassland)
- Built environment (landuse=residential/commercial/industrial)

**Output fields to add:**
- `landuse_class`
- `landuse_type`
- `landuse_area_sqkm`
- `is_greenspace` (boolean flag)

## 2. Calculate Greenspace Metrics

**For analysis:**
- % time in greenspace (dwell-weighted)
- % time in parks specifically
- Subject-level greenspace exposure variability

## 3. Park Accessibility as Context Variable

**Calculate distance to nearest park for:**
- Points NOT in parks
- Characterize urban greenspace access
- Potential moderator for alcohol/health outcomes

## 4. Combine with Existing Enrichment

**Multi-scale environmental context:**
- ADI scores (neighborhood deprivation)
- Landuse (area-level environment type)
- POI (specific facility proximity)
- Creates rich environmental profiles for each GPS point

## Cleanup

```{r}
disconnect_db(con)
```
