---
title: "Enrich GPS Data with Spatial Context"
author: "Christopher Janssen"
date: "`r lubridate::today()`"
format:
  html:
    self-contained: true
editor_options:
  chunk_output_type: console
editor:
  markdown:
    wrap: 72
---

# GPS Data Enrichment

This notebook enriches GPS data with spatial context from the database:

- **ADI scores**: Census block group deprivation index
- **Nearest POI**: Hierarchical matching to OpenStreetMap points of interest

**Input:** `gps_enriched.csv` from research drive
**Output:** `gps_enriched_all.csv` with added spatial context
**POI Distance Limit:** 20 meters

## Setup

```{r}
source(here::here("scripts/r/setup.R"))
source(here::here("scripts/r/connection.R"))

# Connect to database
con <- connect_to_db()
```

## Load GPS Data

```{r}
# Filepath
gps_path <- str_c(path_shared, "/gps_enriched.csv")

# read data
gps_data <- read_csv(gps_path, show_col_types = FALSE)

nrow(gps_data)
```

```{r}
glimpse(gps_data)
```

## Load GPS Points into Temporary Database Table

For efficient spatial queries, we'll load GPS points into a temporary database table with PostGIS geometries.

```{r}
# Select minimal columns needed for spatial joins
gps_spatial <- gps_data |>
  mutate(row_id = row_number()) |>
  select(row_id, lat, lon)

# Write to temporary table
dbWriteTable(con, "temp_gps_points", gps_spatial, temporary = TRUE, overwrite = TRUE, row.names = FALSE)
```

```{r}
# Create geometry column
dbExecute(con, "
ALTER TABLE temp_gps_points
ADD COLUMN geom GEOMETRY(Point, 4326);
")

dbExecute(con, "
UPDATE temp_gps_points
SET geom = ST_SetSRID(ST_MakePoint(lon, lat), 4326);
")
```

```{r}
# Create spatial index for performance
dbExecute(con, "
CREATE INDEX idx_temp_gps_geom ON temp_gps_points USING GIST(geom);
")
```

```{r}
# Verify
dbGetQuery(con, "
SELECT COUNT(*) as total_points, COUNT(geom) as with_geometry
FROM temp_gps_points;
")
```

## Enrich with ADI Scores

Spatial join to match GPS points with census block group ADI scores.

```{r}
# Spatial join: point-in-polygon
#
# R-equivalent logic:
#   gps_data |>
#     left_join(adi_scores, by = st_within(gps_point, adi_polygon))
#
# SQL Explanation:
#   - LEFT JOIN: Keep all GPS points, even if no ADI match (R: left_join)
#   - ST_Within: Check if GPS point falls inside ADI polygon (R: st_within)

adi_results <- dbGetQuery(con, "
SELECT
    t.row_id,
    a.fips_2020,
    a.adi_national_percentile,
    a.adi_state_decile
FROM temp_gps_points t
LEFT JOIN public_data.adi_scores a
    ON ST_Within(t.geom, a.geometry)
ORDER BY t.row_id;
")

nrow(adi_results)
```

```{r}
# Check match rate
adi_results |>
  summarise(
    total_points = n(),
    with_adi = sum(!is.na(adi_national_percentile)),
    match_rate = round(sum(!is.na(adi_national_percentile)) / n() * 100, 2)
  )
```

## Enrich with Nearest POI

### How the POI Queries Work

The POI enrichment queries find the nearest point of interest within 20 meters for each GPS point. Here's how they work:

**R-Equivalent Logic:**
```r
# What we're doing in R terms:
gps_data |>
  group_by(row_id) |>
  mutate(
    nearest_poi = find_closest_poi(this_point, all_poi, max_dist = 20)
  ) |>
  filter(distance <= 20) |>
  slice_head(n = 1)  # Keep only the nearest match
```

**SQL Pattern Explanation:**

1. **`CROSS JOIN LATERAL`** = "For each GPS point, run this subquery"
   - Like a nested loop or `map()` function
   - Lets us search POI table for each GPS row independently

2. **`DISTINCT ON (gps.row_id)`** = "Keep only the first match per GPS point"
   - R equivalent: `group_by(row_id) |> slice_head(n = 1)`
   - Ensures we get exactly one result per GPS point (or zero if no match)

3. **`ORDER BY poi.geom <-> gps.geom`** = "Sort by nearest distance using spatial index"
   - The `<->` operator is PostGIS's fast distance operator
   - Uses spatial indexes for extremely fast lookup (milliseconds per point)
   - R equivalent: `arrange(distance)` but optimized

4. **`ST_DWithin(..., 20)`** = "Only consider POI within 20 meters"
   - Pre-filters POI before distance calculation
   - R equivalent: `filter(distance <= 20)`

5. **`::geography`** = "Use accurate meter-based distance on Earth's surface"
   - Converts from degrees to true meters
   - R equivalent: transforming to a projected CRS

6. **`LIMIT 1`** = "Return only the nearest POI for this GPS point"
   - Combined with ORDER BY, gets the closest match

**Why SQL Instead of R:**
- **Performance**: With 1.24M GPS points and 85K POI, PostGIS spatial indexes make this fast
- **Memory**: Database handles data without loading everything into R
- **Accuracy**: PostGIS geography type gives true meter distances

### Nearest POI - Overall

Find nearest POI of any type (excluding noise categories) within 20m.

```{r}
# Define noise types to exclude
noise_filter <- "
WHERE poi.class NOT IN ('man_made', 'natural', 'military', 'emergency', 'healthcare')
  AND poi.type NOT IN ('parking', 'bench', 'bicycle_parking', 'shelter',
                       'waste_basket', 'toilets', 'loading_dock', 'waste_disposal',
                       'drinking_water', 'grave_yard')
"
```

```{r}
# Find nearest POI within 20m
#
# Query breakdown:
#   1. For each GPS point (CROSS JOIN LATERAL)
#   2. Find POI within 20m (ST_DWithin filter)
#   3. Sort by distance (ORDER BY <-> using spatial index)
#   4. Keep only nearest (LIMIT 1)
#   5. Return one result per GPS point (DISTINCT ON)

nearest_poi <- dbGetQuery(con, str_c("
SELECT DISTINCT ON (gps.row_id)
    gps.row_id,
    poi.class as nearest_poi_class,
    poi.type as nearest_poi_type,
    ROUND(ST_Distance(gps.geom::geography, poi.geom::geography)::numeric, 2) as nearest_poi_distance_m
FROM temp_gps_points gps
CROSS JOIN LATERAL (
    SELECT class, type, geom
    FROM public_data.osm_poi poi
    ", noise_filter, "
      AND ST_DWithin(poi.geom::geography, gps.geom::geography, 20)
    ORDER BY poi.geom <-> gps.geom
    LIMIT 1
) poi
ORDER BY gps.row_id;
"))

nrow(nearest_poi)
```

```{r}
# Check match rate
tibble(
  total_points = nrow(gps_data),
  with_nearest_poi = nrow(nearest_poi),
  match_rate = round(nrow(nearest_poi) / nrow(gps_data) * 100, 2)
)
```

## Enrich with Nearest POI by Major Class

Find nearest POI within each major class (shop, amenity, leisure, tourism).

**Note:** These queries follow the same pattern as above, but filter to specific POI classes.

### Nearest Shop

```{r}
# Same pattern as overall nearest POI, but filtering WHERE class = 'shop'
nearest_shop <- dbGetQuery(con, "
SELECT DISTINCT ON (gps.row_id)
    gps.row_id,
    poi.type as nearest_shop_type,
    ROUND(ST_Distance(gps.geom::geography, poi.geom::geography)::numeric, 2) as nearest_shop_distance_m
FROM temp_gps_points gps
CROSS JOIN LATERAL (
    SELECT type, geom
    FROM public_data.osm_poi poi
    WHERE poi.class = 'shop'
      AND ST_DWithin(poi.geom::geography, gps.geom::geography, 20)
    ORDER BY poi.geom <-> gps.geom
    LIMIT 1
) poi
ORDER BY gps.row_id;
")

nrow(nearest_shop)
```

### Nearest Amenity

```{r}
# Same pattern, filtering WHERE class = 'amenity' (excluding noise types)
nearest_amenity <- dbGetQuery(con, "
SELECT DISTINCT ON (gps.row_id)
    gps.row_id,
    poi.type as nearest_amenity_type,
    ROUND(ST_Distance(gps.geom::geography, poi.geom::geography)::numeric, 2) as nearest_amenity_distance_m
FROM temp_gps_points gps
CROSS JOIN LATERAL (
    SELECT type, geom
    FROM public_data.osm_poi poi
    WHERE poi.class = 'amenity'
      AND poi.type NOT IN ('parking', 'bench', 'bicycle_parking', 'shelter',
                           'waste_basket', 'toilets', 'loading_dock', 'waste_disposal',
                           'drinking_water', 'grave_yard')
      AND ST_DWithin(poi.geom::geography, gps.geom::geography, 20)
    ORDER BY poi.geom <-> gps.geom
    LIMIT 1
) poi
ORDER BY gps.row_id;
")

nrow(nearest_amenity)
```

### Nearest Leisure

```{r}
# Same pattern, filtering WHERE class = 'leisure'
nearest_leisure <- dbGetQuery(con, "
SELECT DISTINCT ON (gps.row_id)
    gps.row_id,
    poi.type as nearest_leisure_type,
    ROUND(ST_Distance(gps.geom::geography, poi.geom::geography)::numeric, 2) as nearest_leisure_distance_m
FROM temp_gps_points gps
CROSS JOIN LATERAL (
    SELECT type, geom
    FROM public_data.osm_poi poi
    WHERE poi.class = 'leisure'
      AND ST_DWithin(poi.geom::geography, gps.geom::geography, 20)
    ORDER BY poi.geom <-> gps.geom
    LIMIT 1
) poi
ORDER BY gps.row_id;
")

nrow(nearest_leisure)
```

### Nearest Tourism

```{r}
# Same pattern, filtering WHERE class = 'tourism'
nearest_tourism <- dbGetQuery(con, "
SELECT DISTINCT ON (gps.row_id)
    gps.row_id,
    poi.type as nearest_tourism_type,
    ROUND(ST_Distance(gps.geom::geography, poi.geom::geography)::numeric, 2) as nearest_tourism_distance_m
FROM temp_gps_points gps
CROSS JOIN LATERAL (
    SELECT type, geom
    FROM public_data.osm_poi poi
    WHERE poi.class = 'tourism'
      AND ST_DWithin(poi.geom::geography, gps.geom::geography, 20)
    ORDER BY poi.geom <-> gps.geom
    LIMIT 1
) poi
ORDER BY gps.row_id;
")

nrow(nearest_tourism)
```

## Enrich with Risk-Relevant POI Categories

**Note:** These queries use the same pattern, but filter to research-relevant POI types.

### Nearest Alcohol Venue (On-Premise)

Bars, pubs, nightclubs, biergartens.

```{r}
# Same pattern, filtering WHERE type IN ('bar', 'pub', 'nightclub', 'biergarten')
nearest_alcohol_venue <- dbGetQuery(con, "
SELECT DISTINCT ON (gps.row_id)
    gps.row_id,
    poi.type as nearest_alcohol_venue_type,
    ROUND(ST_Distance(gps.geom::geography, poi.geom::geography)::numeric, 2) as nearest_alcohol_venue_distance_m
FROM temp_gps_points gps
CROSS JOIN LATERAL (
    SELECT type, geom
    FROM public_data.osm_poi poi
    WHERE poi.class = 'amenity'
      AND poi.type IN ('bar', 'pub', 'nightclub', 'biergarten')
      AND ST_DWithin(poi.geom::geography, gps.geom::geography, 20)
    ORDER BY poi.geom <-> gps.geom
    LIMIT 1
) poi
ORDER BY gps.row_id;
")

nrow(nearest_alcohol_venue)
```

### Nearest Alcohol Retail (Off-Premise)

Liquor stores, wine shops, breweries.

```{r}
# Same pattern, filtering across multiple classes (shop:alcohol/wine, craft:brewery)
nearest_alcohol_retail <- dbGetQuery(con, "
SELECT DISTINCT ON (gps.row_id)
    gps.row_id,
    CASE
        WHEN poi.class = 'shop' THEN poi.type
        WHEN poi.class = 'craft' THEN 'brewery'
    END as nearest_alcohol_retail_type,
    ROUND(ST_Distance(gps.geom::geography, poi.geom::geography)::numeric, 2) as nearest_alcohol_retail_distance_m
FROM temp_gps_points gps
CROSS JOIN LATERAL (
    SELECT class, type, geom
    FROM public_data.osm_poi poi
    WHERE ((poi.class = 'shop' AND poi.type IN ('alcohol', 'wine'))
           OR (poi.class = 'craft' AND poi.type = 'brewery'))
      AND ST_DWithin(poi.geom::geography, gps.geom::geography, 20)
    ORDER BY poi.geom <-> gps.geom
    LIMIT 1
) poi
ORDER BY gps.row_id;
")

nrow(nearest_alcohol_retail)
```

### Nearest Food Venue

Restaurants, cafes, fast food.

```{r}
# Same pattern, filtering WHERE type IN ('restaurant', 'cafe', 'fast_food')
nearest_food_venue <- dbGetQuery(con, "
SELECT DISTINCT ON (gps.row_id)
    gps.row_id,
    poi.type as nearest_food_venue_type,
    ROUND(ST_Distance(gps.geom::geography, poi.geom::geography)::numeric, 2) as nearest_food_venue_distance_m
FROM temp_gps_points gps
CROSS JOIN LATERAL (
    SELECT type, geom
    FROM public_data.osm_poi poi
    WHERE poi.class = 'amenity'
      AND poi.type IN ('restaurant', 'cafe', 'fast_food')
      AND ST_DWithin(poi.geom::geography, gps.geom::geography, 20)
    ORDER BY poi.geom <-> gps.geom
    LIMIT 1
) poi
ORDER BY gps.row_id;
")

nrow(nearest_food_venue)
```

## Join All Enrichments

```{r}
# Start with original GPS data and add row_id
gps_enriched <- gps_data |>
  mutate(row_id = row_number())

# Join ADI data
gps_enriched <- gps_enriched |>
  left_join(adi_results, by = "row_id")

# Join overall nearest POI
gps_enriched <- gps_enriched |>
  left_join(nearest_poi, by = "row_id")

# Join nearest by class
gps_enriched <- gps_enriched |>
  left_join(nearest_shop, by = "row_id") |>
  left_join(nearest_amenity, by = "row_id") |>
  left_join(nearest_leisure, by = "row_id") |>
  left_join(nearest_tourism, by = "row_id")

# Join risk-specific categories
gps_enriched <- gps_enriched |>
  left_join(nearest_alcohol_venue, by = "row_id") |>
  left_join(nearest_alcohol_retail, by = "row_id") |>
  left_join(nearest_food_venue, by = "row_id")

# Remove temporary row_id
gps_enriched <- gps_enriched |>
  select(-row_id)

nrow(gps_enriched)
```

## Summary Statistics

### ADI Coverage

```{r}
gps_enriched |>
  summarise(
    total_points = n(),
    with_adi = sum(!is.na(adi_national_percentile)),
    match_rate_pct = round(sum(!is.na(adi_national_percentile)) / n() * 100, 2)
  ) |>
  knitr::kable()
```

### POI Coverage

```{r}
tibble(
  category = c("Overall POI", "Shop", "Amenity", "Leisure", "Tourism",
               "Alcohol Venue", "Alcohol Retail", "Food Venue"),
  matches = c(
    sum(!is.na(gps_enriched$nearest_poi_type)),
    sum(!is.na(gps_enriched$nearest_shop_type)),
    sum(!is.na(gps_enriched$nearest_amenity_type)),
    sum(!is.na(gps_enriched$nearest_leisure_type)),
    sum(!is.na(gps_enriched$nearest_tourism_type)),
    sum(!is.na(gps_enriched$nearest_alcohol_venue_type)),
    sum(!is.na(gps_enriched$nearest_alcohol_retail_type)),
    sum(!is.na(gps_enriched$nearest_food_venue_type))
  ),
  match_rate_pct = round(matches / nrow(gps_enriched) * 100, 2)
) |>
  knitr::kable()
```

### Risk-Relevant POI Distribution

```{r}
# Alcohol venue types
gps_enriched |>
  filter(!is.na(nearest_alcohol_venue_type)) |>
  count(nearest_alcohol_venue_type, sort = TRUE) |>
  knitr::kable()
```

```{r}
# Food venue types
gps_enriched |>
  filter(!is.na(nearest_food_venue_type)) |>
  count(nearest_food_venue_type, sort = TRUE) |>
  knitr::kable()
```

## Write Enriched Data

```{r}
# Output path
output_path <- str_c(path_shared, "/gps_enriched_all.csv")

# Write enriched data
write_csv(gps_enriched, output_path)
```

```{r}
# Verify file was written
file.info(output_path)$size / 1024^2  # Size in MB
```

## Cleanup

```{r}
# Drop temporary table
dbExecute(con, "DROP TABLE IF EXISTS temp_gps_points;")

# Disconnect
disconnect_db(con)
```

