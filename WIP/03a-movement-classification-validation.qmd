---
title: "GPS22 Project: Movement Classification Validation"
author: "Christopher Janssen"
date: "`r lubridate::today()`"
format:
  html:
    self-contained: true
    code-fold: false
    toc: true
    toc-depth: 3
editor_options:
  chunk_output_type: console
editor:
  markdown:
    wrap: 72
---

# Movement Classification Validation Analysis

This notebook compares your lab's speed-based movement classification (4 mph threshold) against the GPS apps' built-in movement detection (`sgmnt_type` field) to determine which approach produces better clustering results.

## Setup

```{r setup, message=FALSE}
source(here::here("scripts/r/setup.R"))
source(here::here("scripts/r/database.R"))
library(skimr)
library(corrplot)
library(ggplot2)
```

```{r connect}
con <- connect_gps_db()
```

## Data Loading with App Classifications

Load GPS data including the original app movement classifications:

```{r load-data}
# Load GPS data with app classifications
gps_comparison <- dbGetQuery(con, "
  SELECT 
    s.subid,
    rg.lat,
    rg.lon,
    rg.time,
    rg.sgmnt_type as app_classification,
    CASE 
      WHEN rg.sgmnt_type = 'place' THEN 'stationary'
      WHEN rg.sgmnt_type = 'move' THEN 'transition'
      WHEN rg.sgmnt_type = 'off' THEN 'inactive'
      ELSE 'unknown'
    END as app_movement_state
  FROM raw_gps_points rg
  JOIN subjects s ON rg.subject_id = s.id
  WHERE rg.lat IS NOT NULL 
    AND rg.lon IS NOT NULL
  ORDER BY s.subid, rg.time
")

# Convert timestamps
gps_comparison <- gps_comparison |>
  mutate(
    dttm_obs = as.POSIXct(time, format = "%Y-%m-%dT%H:%M:%SZ", tz = "UTC"),
    dttm_obs = with_tz(dttm_obs, tz = "America/Chicago")
  ) |>
  arrange(subid, dttm_obs)

message("Loaded ", format(nrow(gps_comparison), big.mark = ","), " GPS points")
```

## App Classification Distribution

Let's see what the apps actually classified:

```{r app-distribution}
app_summary <- gps_comparison |>
  count(app_classification, app_movement_state) |>
  mutate(
    percentage = round(n / sum(n) * 100, 1),
    cumulative_pct = cumsum(percentage)
  )

app_summary |>
  knitr::kable(caption = "Distribution of App Movement Classifications")
```

**Key Insight**: `{r} round(app_summary |> filter(is.na(app_classification)) |> pull(percentage), 1)`% of your GPS points have no app classification! This suggests the apps weren't always making movement decisions.

## Lab Speed-Based Classification

Now calculate your lab's speed-based classification using the same logic from notebook 03:

```{r lab-classification}
# Calculate distances, durations, and speeds (same as notebook 03)
gps_comparison <- gps_comparison |>
  group_by(subid) |>
  mutate(
    # Haversine distance in meters, then convert to miles
    dist_m = if_else(
      row_number() == 1, 
      0,
      distHaversine(
        cbind(lag(lon), lag(lat)), 
        cbind(lon, lat)
      )
    ),
    dist_miles = dist_m / 1609.344,
    
    # Duration between consecutive points in minutes
    duration_mins = if_else(
      row_number() == 1, 
      0,
      as.numeric(difftime(dttm_obs, lag(dttm_obs), units = "mins"))
    ),
    
    # Speed in miles per hour
    speed_mph = if_else(
      duration_mins > 0, 
      dist_miles / (duration_mins / 60), 
      0
    )
  ) |>
  ungroup()

# Apply lab quality filters (same as notebook 03)
speed_threshold_mph <- 100
rows_before <- nrow(gps_comparison)

gps_comparison <- gps_comparison |>
  mutate(
    # Apply lab filtering rules
    duration_clean = case_when(
      dist_miles > 0.01 & duration_mins == 0 ~ NA_real_,
      speed_mph > speed_threshold_mph ~ NA_real_,
      duration_mins > 0.5 & dist_miles > 0.31 ~ NA_real_,
      TRUE ~ duration_mins
    ),
    
    speed_clean = case_when(
      !is.na(duration_clean) & duration_clean > 0 ~ dist_miles / (duration_clean / 60),
      TRUE ~ 0
    )
  ) |>
  filter(!is.na(duration_clean)) |>
  select(-duration_mins, -speed_mph) |>
  rename(
    duration_mins = duration_clean,
    speed_mph = speed_clean
  )

# Apply lab movement classification (4 mph threshold)
stationary_threshold_mph <- 4

gps_comparison <- gps_comparison |>
  mutate(
    lab_movement_state = if_else(speed_mph <= stationary_threshold_mph, "stationary", "transition")
  )

message("After lab quality filters: ", format(nrow(gps_comparison), big.mark = ","), 
        " valid GPS points (removed ", format(rows_before - nrow(gps_comparison), big.mark = ","), 
        " problematic records)")
```

## Classification Comparison

Now compare the two approaches:

```{r comparison-analysis}
# Compare classifications where both are available
classification_comparison <- gps_comparison |>
  filter(!is.na(app_classification)) |>  # Only points where app made a decision
  select(subid, app_movement_state, lab_movement_state, speed_mph, dist_miles, duration_mins) |>
  mutate(
    classifications_match = app_movement_state == lab_movement_state
  )

# Agreement matrix
agreement_matrix <- classification_comparison |>
  count(app_movement_state, lab_movement_state) |>
  pivot_wider(names_from = lab_movement_state, values_from = n, values_fill = 0)

agreement_matrix |>
  knitr::kable(caption = "App vs Lab Classification Agreement Matrix")

# Overall agreement rate
total_comparable <- nrow(classification_comparison)
agreements <- sum(classification_comparison$classifications_match)
agreement_rate <- round(agreements / total_comparable * 100, 1)

message("Classification Agreement Rate: ", agreement_rate, "% (", 
        format(agreements, big.mark = ","), " out of ", 
        format(total_comparable, big.mark = ","), " comparable points)")
```

## Disagreement Analysis

Let's analyze where the two methods disagree:

```{r disagreement-analysis}
# Focus on disagreements
disagreements <- classification_comparison |>
  filter(!classifications_match) |>
  mutate(
    disagreement_type = paste0(app_movement_state, "_vs_", lab_movement_state)
  )

disagreement_summary <- disagreements |>
  count(disagreement_type) |>
  mutate(
    percentage = round(n / sum(n) * 100, 1),
    total_pct = round(n / nrow(classification_comparison) * 100, 1)
  ) |>
  arrange(desc(n))

disagreement_summary |>
  knitr::kable(caption = "Types of Classification Disagreements")
```

## Speed Distribution Analysis

Examine speed distributions for each app classification:

```{r speed-analysis}
# Speed distributions by app classification
speed_by_app <- classification_comparison |>
  group_by(app_movement_state) |>
  summarise(
    n_points = n(),
    mean_speed = round(mean(speed_mph, na.rm = TRUE), 2),
    median_speed = round(median(speed_mph, na.rm = TRUE), 2),
    q25_speed = round(quantile(speed_mph, 0.25, na.rm = TRUE), 2),
    q75_speed = round(quantile(speed_mph, 0.75, na.rm = TRUE), 2),
    max_speed = round(max(speed_mph, na.rm = TRUE), 2),
    .groups = "drop"
  )

speed_by_app |>
  knitr::kable(caption = "Speed Statistics by App Classification")

# Create speed distribution plot

classification_comparison |>
  filter(speed_mph <= 20) |>  # Focus on reasonable speeds for visualization
  ggplot(aes(x = speed_mph, fill = app_movement_state)) +
  geom_histogram(alpha = 0.7, bins = 50, position = "identity") +
  geom_vline(xintercept = 4, color = "red", linetype = "dashed") +
  annotate("text", x = 4.5, y = Inf, label = "Lab Threshold (4 mph)", 
           vjust = 1.4, hjust = 0, color = "red") +
  facet_wrap(~app_movement_state, scales = "free_y") +
  labs(
    title = "Speed Distributions by App Movement Classification",
    subtitle = "Red line shows lab's 4 mph threshold",
    x = "Speed (mph)",
    y = "Count of GPS Points",
    fill = "App Classification"
  ) +
  theme_bw()
```

## Key Findings

```{r key-findings}
# Calculate key insights
app_stationary_above_4mph <- classification_comparison |>
  filter(app_movement_state == "stationary", speed_mph > 4) |>
  nrow()

app_moving_below_4mph <- classification_comparison |>
  filter(app_movement_state == "transition", speed_mph <= 4) |>
  nrow()

lab_false_positives <- round(app_stationary_above_4mph / 
  sum(classification_comparison$app_movement_state == "stationary") * 100, 1)

lab_false_negatives <- round(app_moving_below_4mph / 
  sum(classification_comparison$app_movement_state == "transition") * 100, 1)

cat("Key Classification Issues with 4 mph Threshold:\n")
cat("• App says 'stationary' but lab says 'moving' (FALSE POSITIVES): ", 
    format(app_stationary_above_4mph, big.mark = ","), " points (", lab_false_positives, "% of app-stationary)\n")
cat("• App says 'moving' but lab says 'stationary' (FALSE NEGATIVES): ", 
    format(app_moving_below_4mph, big.mark = ","), " points (", lab_false_negatives, "% of app-moving)\n")

cat("\n=== CRITICAL FINDINGS ===\n")
cat("The 4 mph threshold has MAJOR issues:\n\n")
cat("1. **157,276 False Negatives (96.8% of disagreements)**\n")
cat("   - Apps correctly detected movement, but speed threshold called it 'stationary'\n")
cat("   - This represents 30.4% of ALL comparable GPS points\n")
cat("   - Likely includes: slow walking (2-3 mph), parking lots, heavy traffic\n\n")

cat("2. **Why Apps Are Smarter Than Speed Alone**\n")
cat("   - Apps use acceleration patterns, GPS confidence, temporal context\n")
cat("   - Your speed calc only sees: distance_between_points / time_between_points\n")
cat("   - Apps distinguish GPS drift from actual slow movement\n\n")

cat("3. **Impact on Clustering Quality**\n")
cat("   - FALSE CLUSTERING: Mixing stationary points with slow movement\n")
cat("   - INFLATED DURATIONS: Including walking time as 'visit time'\n")
cat("   - SPATIAL SCATTER: Clusters become larger and less precise\n\n")

cat("4. **Speed Distribution Evidence**\n")
cat("   - App 'transition' points: median 12.58 mph, mean 22.52 mph\n")
cat("   - Many legitimate movements occur at 2-6 mph (walking, parking)\n")
cat("   - 4 mph threshold is simply too low for human movement patterns\n")
```

### **Recommendation: Hybrid Approach**
```{r hybrid-approach}
# Create improved classification using app data when available
gps_comparison <- gps_comparison |>
  mutate(
    improved_movement_state = case_when(
      # Use app classification when available and confident
      app_movement_state %in% c("stationary", "transition") ~ app_movement_state,
      # Fall back to lab method for unknown/inactive points
      is.na(app_classification) | app_movement_state == "unknown" ~ lab_movement_state,
      app_movement_state == "inactive" ~ "inactive",
      TRUE ~ lab_movement_state
    )
  )

# Compare all three approaches
final_comparison <- gps_comparison |>
  count(app_movement_state, lab_movement_state, improved_movement_state) |>
  arrange(desc(n))

cat("\n=== RECOMMENDATIONS ===\n")
cat("Based on this analysis, here are three approaches:\n\n")

cat("**OPTION 1: Raise Speed Threshold**\n")
cat("- Change from 4 mph to 8-10 mph based on transition median (12.58 mph)\n")
cat("- Quick fix but still crude compared to app intelligence\n\n")

cat("**OPTION 2: Hybrid Approach (RECOMMENDED)**\n")
cat("Use the 'improved_movement_state' which:\n")
cat("1. Uses app classifications when available (", 
    format(sum(!is.na(gps_comparison$app_classification)), big.mark = ","), " points)\n")
cat("2. Falls back to your speed threshold for unclassified points (", 
    format(sum(is.na(gps_comparison$app_classification)), big.mark = ","), " points)\n")
cat("3. Leverages sophisticated app algorithms where possible\n\n")

cat("**OPTION 3: App Classifications Only**\n")
cat("- Use only points where apps made decisions\n")
cat("- Purest approach but loses ~52% of data\n")
cat("- May be worth it for higher quality clusters\n\n")

cat("**Expected Improvements with Hybrid Approach:**\n")
cat("- More focused, compact clusters\n")
cat("- More accurate visit durations\n")
cat("- Less noise from GPS drift and slow movement\n")
cat("- Better foundation for machine learning features\n")
```

## Next Steps: Testing the Hybrid Approach

### **Immediate Actions**

1. **Test Clustering Quality**: Re-run your clustering analysis using `improved_movement_state`
2. **Compare Results**: Analyze differences in cluster count, sizes, and durations
3. **Validate Against Reality**: Do the new clusters make more sense geographically?

### **Educational Takeaway**

This analysis demonstrates a crucial data science principle: **domain expertise matters**. GPS app developers spent years optimizing movement detection algorithms using:
- Machine learning on millions of GPS traces
- Sensor fusion (GPS + accelerometer + gyroscope)
- Contextual understanding of human movement patterns

A simple speed threshold, while intuitive, misses these nuances. This is why:
- **68.6% agreement** isn't terrible, but 31.4% disagreement is substantial
- **157,276 false negatives** represent real clustering quality issues
- **Apps' median transition speed (12.58 mph)** suggests 4 mph threshold is too conservative

The hybrid approach should give you much higher quality input for your duration-based clustering algorithm, leading to more meaningful location clusters for your addiction recovery research.

```{r save-results}
# Save comparison data for use in clustering validation
saveRDS(gps_comparison, here::here("data/movement_classification_comparison.rds"))
message("✓ Saved comparison results for clustering validation")
```